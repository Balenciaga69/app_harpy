# Character 重構總結 (v0.5)

## 重大變更

### 1. ID 系統簡化

- ✅ **移除 branded types**: 不再使用 `CharacterId`，直接使用 `string`
- ✅ **Character ID = Name**: 簡化設計，使用角色名稱作為 ID

### 2. 管理器系統 (Manager Pattern)

引入專門的管理器來組織職責，遵循 **Single Responsibility Principle**：

#### **EquipmentManager** (`equipment.manager.ts`)

- 管理多個裝備槽位：`weapon`, `helmet`, `armor`, `necklace`
- 每個槽位只能裝備一個裝備
- 自動處理裝備/卸載時的效果應用

```typescript
// 使用範例
character.equipItem(new Stormblade(), 'weapon', context)
character.unequipItem('weapon', context)
character.getEquipment('weapon')
character.getAllEquipment()
```

#### **RelicManager** (`relic.manager.ts`)

- 管理可堆疊的遺物
- 相同名稱的遺物會自動堆疊，而非創建多個實例
- 支持查詢堆疊數量

```typescript
// 使用範例
character.addRelic(new PoisonVial(), context)
character.getRelicStackCount('Poison Vial')
character.getRelic('Poison Vial')
character.getAllRelics()
character.removeRelic('Poison Vial', context)
```

#### **UltimateManager** (`ultimate.manager.ts`)

- 管理角色的大絕招
- 簡化大絕招的設置和獲取邏輯

```typescript
// 使用範例
character.setUltimate(new ThunderStrikeUltimate(), context)
const ultimate = character.getUltimate(context)
```

### 3. 循環依賴解決方案

#### 問題

```
IEffect -> CombatContext -> IResourceRegistry -> IEffect
```

#### 解決方案：抽象化 CombatContext

創建 `ICombatContext` 介面：

```typescript
// combat.context.interface.ts
export interface ICombatContext {
  readonly eventBus: EventBus
  readonly rng: CombatRandomGenerator
  readonly registry: IResourceRegistry

  getEntity(id: string): IEntity | undefined
  addEntity(entity: IEntity): void
  // ...其他方法
}

// combat.context.ts
export class CombatContext implements ICombatContext {
  // 具體實現
}
```

**效果**:

- ✅ 打破循環依賴：`IEffect -> ICombatContext` (interface, not class)
- ✅ 依賴倒置原則：高層模塊依賴抽象而非具體實現
- ✅ 更好的可測試性：可以輕鬆 mock ICombatContext

### 4. API 變更

#### Character 構造函數

```typescript
// 舊版
const char = new Character(config, context)

// 新版 (context 可選)
const char = new Character(config, context) // 有 context 時立即初始化 ultimate
const char = new Character(config) // 沒有 context 時延遲初始化
```

#### 裝備系統

```typescript
// 舊版
character.equipItem(equipment, context)
character.getEquippedItem()

// 新版
character.equipItem(equipment, 'weapon', context) // 需要指定槽位
character.getEquipment('weapon') // 按槽位獲取
character.getAllEquipment() // 獲取所有裝備
```

#### 遺物系統

```typescript
// 舊版
character.addRelic(relic, context)
character.getAllRelics()

// 新版 (新增堆疊功能)
character.addRelic(relic, context) // 自動堆疊
character.getRelicStackCount('Poison Vial') // 查詢堆疊數量
character.getRelic('Poison Vial') // 按名稱獲取
character.getAllRelics()
character.removeRelic('Poison Vial', context)
```

#### Ultimate 系統

```typescript
// 舊版
character.getUltimate()
character.setUltimate(ultimate)

// 新版 (需要 context)
character.getUltimate(context)
character.setUltimate(ultimate, context)
```

## 架構改進

### 職責分離

```
Character (協調者)
├── AttributeContainer (屬性儲存)
├── AttributeCalculator (屬性計算)
├── EffectManager (效果管理)
├── EquipmentManager (裝備管理) ← 新增
├── RelicManager (遺物管理) ← 新增
└── UltimateManager (大絕招管理) ← 新增
```

### 優點

1. **更清晰的職責劃分**: 每個 Manager 只負責一件事
2. **更容易擴展**: 新增功能只需添加新的 Manager
3. **更好的可測試性**: 可以獨立測試每個 Manager
4. **減少 Character 類的複雜度**: 從 279 行減少到更模塊化的結構

## 破壞性變更清單

### 必須更新的程式碼

1. ✅ `equipItem()` 調用需要添加 `slot` 參數
2. ✅ `getUltimate()` 和 `setUltimate()` 需要傳入 `context`
3. ✅ 所有使用 `CharacterId` 類型的地方改為 `string`

### 已更新的檔案

- ✅ `tick.action.system.ts` - 更新 `getUltimate(context)` 調用
- ✅ `simpleCombat.ts` - 更新 `equipItem()` 調用，添加槽位參數

## 後續建議

### 1. 考慮添加裝備槽位驗證

```typescript
// 在 equipment.model.ts 中添加
export interface Equipment {
  readonly validSlots: EquipmentSlot[] // 限制可裝備的槽位
}
```

### 2. 考慮添加 Manager 的統一介面

```typescript
interface IManager<T> {
  clear(context: ICombatContext): void
  // 其他共通方法
}
```

### 3. 考慮使用 Composite Pattern 整合所有 Managers

```typescript
class CharacterManagers {
  constructor(
    public effects: EffectManager,
    public equipment: EquipmentManager,
    public relics: RelicManager,
    public ultimates: UltimateManager
  ) {}
}
```

## 測試建議

1. 測試裝備槽位衝突
2. 測試遺物堆疊邏輯
3. 測試 pending ultimate 的延遲初始化
4. 測試所有 Manager 的 clear 功能
