# v0.5 Milestone: Resource Registry & DIP Implementation

**Target Date:** TBD  
**Status:** Planning  
**Priority:** High

**Terminology Note:** This implements a **Resource Registry**, NOT an Object Pool. Registry is for cataloging/lookup, Pool is for object reuse.

---

## Objectives

1. Implement Resource Registry abstraction to decouple resource ownership
2. Practice Dependency Inversion Principle (DIP) throughout combat module
3. Lay foundation for DB/Cache integration in future versions

---

## Key Changes

### 1. Resource Registry Layer (New)

**Location:** `src/modules/combat/infra/resource-registry/`

**Components:**

- `IResourceRegistry` - Abstraction interface
- `InMemoryResourceRegistry` - In-memory implementation (v0.5)
- `RedisResourceRegistry` - Redis implementation (v0.6+)

**Responsibilities:**

- Register and retrieve Effect, Ultimate, Equipment, Relic by ID
- Support both synchronous (in-memory) and asynchronous (Redis) queries
- Provide lifecycle management (clear, dispose)

---

### 2. Character Refactoring

**Before:**

```typescript
class Character {
  private effects: IEffect[]
  private ultimate: IUltimateAbility
}
```

**After:**

```typescript
class Character {
  private effectIds: string[]
  private ultimateId: string | null
  private readonly registry: IResourceRegistry

  getEffects(): IEffect[] {
    return this.effectIds.map((id) => this.registry.getEffect(id)).filter((e) => e !== undefined)
  }
}
```

**Benefits:**

- Easier serialization (only IDs, not complex objects)
- Testable via mock registry
- Memory efficient (shared instances)

---

### 3. CombatContext Enhancement

**Injection Point:**

```typescript
new CombatContext(
  eventBus,
  rng,
  registry, // NEW: IResourceRegistry
  tick
)
```

**Usage:**

- All systems query resources via `context.registry`
- No direct instantiation of Effect/Ultimate in combat logic

---

## Architecture Impact

### Layer Dependency (Before)

```
Coordination → Domain (direct dependency on Character/Effect)
```

### Layer Dependency (After)

```
Coordination → IResourceRegistry ← Domain
             ↑
          Context
```

**Key Improvement:**

- Coordination no longer directly depends on Domain implementation
- Dependencies point to abstractions (interfaces)
- Follows Dependency Inversion Principle

---

## Migration Strategy

### Phase 1: Interface & In-Memory (Week 1-2)

- [x] Create `IResourceRegistry` interface
- [x] Implement `InMemoryResourceRegistry`
- [x] Inject into `CombatContext`
- [x] Update `Character` to use IDs + registry injection
- [x] Update all Effect/Ultimate queries
- [x] Update `EffectManager` to register/unregister effects

### Phase 2: Testing & Validation (Week 3)

- [ ] Write unit tests with mock registry
- [ ] Verify no regression in combat logic
- [ ] Performance benchmark (compare with v0.4)

### Phase 3: Documentation (Week 4)

- [x] Update architecture diagrams
- [x] Write migration guide for future DB integration
- [x] Document ID generation strategy (using nanoid)

---

## Known Issues & Risks

### Risk 1: Performance Overhead

**Issue:** Map lookup on every resource access  
**Mitigation:**

- Use local cache in hot paths (e.g., TickActionSystem)
- Benchmark and optimize if needed

### Risk 2: Serialization Complexity

**Issue:** Effects/Ultimates contain functions, can't be directly serialized  
**Mitigation:**

- Use Factory Pattern to reconstruct from serialized data
- Store only configuration data, not function references

### Risk 3: Async Conversion (Future)

**Issue:** Redis registry requires async/await, major refactor  
**Mitigation:**

- Keep v0.5 synchronous (in-memory only)
- Plan async migration in v0.6

### Risk 4: ID Management

**Issue:** Need consistent ID generation across modules  
**Mitigation:**

- Use nanoid for global uniqueness
- Effects auto-generate IDs, other resources use provided IDs

---

## Success Criteria

✅ All combat tests pass with InMemoryResourceRegistry  
✅ Character serialization works (only IDs stored)  
✅ No circular dependencies in resource layer  
✅ Performance < 5% degradation vs v0.4  
✅ Documentation complete

---

## Future Work (v0.6+)

- [ ] Implement `RedisResourceRegistry`
- [ ] Add async/await support
- [ ] Implement caching strategy (LRU cache)
- [ ] Add resource versioning for save compatibility
- [ ] Implement resource pre-loading system

---

## Q&A

### Q1: Why is this called Registry, not Pool?

**A:** **Object Pool** is for managing lifecycle of frequently created/destroyed objects (like DamageEvent), using acquire/release pattern. **Resource Registry** is for cataloging resources for lookup. We're doing lookup, not lifecycle management, so Registry is the correct term.

### Q2: Why not store resources directly in Character?

**A:** Direct storage makes serialization hard, creates circular dependencies, and prevents shared instances. Using IDs + Registry pattern solves all three issues.

### Q3: Will this slow down combat simulation?

**A:** In-memory Map lookup is O(1) and very fast (<1ms). For v0.5, performance impact is negligible. If needed, we can add caching layer.

### Q4: How to handle resource not found?

**A:** Return `undefined` and let caller decide (fail-safe or throw error). Log warning for debugging.

### Q5: Can I still use direct instances in tests?

**A:** Yes! Mock registry can return pre-configured instances. Tests become easier, not harder.

### Q6: What about resources that change during combat (e.g., effect stacks)?

**A:** Character state (stacks, duration) stays in Character. Registry only stores "blueprint" (base config).

### Q7: How to migrate existing save files?

**A:** v0.5 doesn't have saves yet. When implementing in v0.6, write migration script to convert old format to new ID-based format.

### Q7: Why not use dependency injection framework (e.g., InversifyJS)?

**A:** Manual DI is simpler for this project size. Framework adds complexity without much benefit. May reconsider in v1.0.

### Q8: How does this help with multiplayer?

**A:** Resources can be fetched from server via Redis. Multiple clients share same resource pool. Reduces bandwidth (only send IDs, not full objects).

### Q9: What if I need different Effect behavior per character?

**A:** Pool stores base Effect class. Character-specific state (stacks, modifiers) stays in Character. Use composition, not inheritance.

### Q10: Can I pre-load resources at combat start?

**A:** Yes! CombatEngine can call `pool.preload(ids[])` to warm cache before simulation starts.

---

## References

- [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
- [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)
- [Redis Best Practices](https://redis.io/docs/manual/patterns/)

---

**Last Updated:** 2025-12-02  
**Author:** AI Assistant  
**Reviewers:** TBD
