# v0.5 Milestone: Resource Pool & DIP Implementation

**Target Date:** TBD  
**Status:** Planning  
**Priority:** High

---

## Objectives

1. Implement Resource Pool abstraction to decouple resource ownership
2. Practice Dependency Inversion Principle (DIP) throughout combat module
3. Lay foundation for DB/Cache integration in future versions

---

## Key Changes

### 1. Resource Pool Layer (New)

**Location:** `src/modules/combat/infra/resource-pool/`

**Components:**

- `IResourcePool` - Abstraction interface
- `InMemoryResourcePool` - In-memory implementation (v0.5)
- `RedisResourcePool` - Redis implementation (v0.6+)

**Responsibilities:**

- Store and retrieve Effect, Ultimate, Equipment, Relic by ID
- Support both synchronous (in-memory) and asynchronous (Redis) queries
- Provide lifecycle management (clear, dispose)

---

### 2. Character Refactoring

**Before:**

```typescript
class Character {
  private effects: IEffect[]
  private ultimate: IUltimateAbility
}
```

**After:**

```typescript
class Character {
  private effectIds: string[]
  private ultimateId: string | null

  getEffects(): IEffect[] {
    return this.effectIds.map((id) => pool.getEffect(id))
  }
}
```

**Benefits:**

- Easier serialization (only IDs, not complex objects)
- Testable via mock pool
- Memory efficient (shared instances)

---

### 3. CombatContext Enhancement

**Injection Point:**

```typescript
new CombatContext(
  eventBus,
  rng,
  resourcePool, // NEW
  tick
)
```

**Usage:**

- All systems query resources via `context.resourcePool`
- No direct instantiation of Effect/Ultimate in combat logic

---

## Architecture Impact

### Layer Dependency (Before)

```
Coordination → Domain (direct dependency on Character/Effect)
```

### Layer Dependency (After)

```
Coordination → IResourcePool ← Domain
             ↑
          Context
```

**Key Improvement:**

- Coordination no longer directly depends on Domain implementation
- Dependencies point to abstractions (interfaces)
- Follows Dependency Inversion Principle

---

## Migration Strategy

### Phase 1: Interface & In-Memory (Week 1-2)

- [ ] Create `IResourcePool` interface
- [ ] Implement `InMemoryResourcePool`
- [ ] Inject into `CombatContext`
- [ ] Update `Character` to use IDs
- [ ] Update all Effect/Ultimate queries

### Phase 2: Testing & Validation (Week 3)

- [ ] Write unit tests with mock pool
- [ ] Verify no regression in combat logic
- [ ] Performance benchmark (compare with v0.4)

### Phase 3: Documentation (Week 4)

- [ ] Update architecture diagrams
- [ ] Write migration guide for future DB integration
- [ ] Document ID generation strategy

---

## Known Issues & Risks

### Risk 1: Performance Overhead

**Issue:** Map lookup on every resource access  
**Mitigation:**

- Use local cache in hot paths (e.g., TickActionSystem)
- Benchmark and optimize if needed

### Risk 2: Serialization Complexity

**Issue:** Effects/Ultimates contain functions, can't be directly serialized  
**Mitigation:**

- Use Factory Pattern to reconstruct from serialized data
- Store only configuration data, not function references

### Risk 3: Async Conversion (Future)

**Issue:** Redis pool requires async/await, major refactor  
**Mitigation:**

- Keep v0.5 synchronous (in-memory only)
- Plan async migration in v0.6

### Risk 4: ID Management

**Issue:** Need consistent ID generation across modules  
**Mitigation:**

- Use UUID v4 for global uniqueness
- Consider namespace prefixes (e.g., `effect:`, `ultimate:`)

---

## Success Criteria

✅ All combat tests pass with InMemoryResourcePool  
✅ Character serialization works (only IDs stored)  
✅ No circular dependencies in resource layer  
✅ Performance < 5% degradation vs v0.4  
✅ Documentation complete

---

## Future Work (v0.6+)

- [ ] Implement `RedisResourcePool`
- [ ] Add async/await support
- [ ] Implement caching strategy (LRU cache)
- [ ] Add resource versioning for save compatibility
- [ ] Implement resource pre-loading system

---

## Q&A

### Q1: Why not store resources directly in Character?

**A:** Direct storage makes serialization hard, creates circular dependencies, and prevents shared instances. Using IDs + Pool pattern solves all three issues.

### Q2: Will this slow down combat simulation?

**A:** In-memory Map lookup is O(1) and very fast (<1ms). For v0.5, performance impact is negligible. If needed, we can add caching layer.

### Q3: How to handle resource not found?

**A:** Return `undefined` and let caller decide (fail-safe or throw error). Log warning for debugging.

### Q4: Can I still use direct instances in tests?

**A:** Yes! Mock pool can return pre-configured instances. Tests become easier, not harder.

### Q5: What about resources that change during combat (e.g., effect stacks)?

**A:** Character state (stacks, duration) stays in Character. Pool only stores "blueprint" (base config).

### Q6: How to migrate existing save files?

**A:** v0.5 doesn't have saves yet. When implementing in v0.6, write migration script to convert old format to new ID-based format.

### Q7: Why not use dependency injection framework (e.g., InversifyJS)?

**A:** Manual DI is simpler for this project size. Framework adds complexity without much benefit. May reconsider in v1.0.

### Q8: How does this help with multiplayer?

**A:** Resources can be fetched from server via Redis. Multiple clients share same resource pool. Reduces bandwidth (only send IDs, not full objects).

### Q9: What if I need different Effect behavior per character?

**A:** Pool stores base Effect class. Character-specific state (stacks, modifiers) stays in Character. Use composition, not inheritance.

### Q10: Can I pre-load resources at combat start?

**A:** Yes! CombatEngine can call `pool.preload(ids[])` to warm cache before simulation starts.

---

## References

- [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
- [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)
- [Redis Best Practices](https://redis.io/docs/manual/patterns/)

---

**Last Updated:** 2025-12-02  
**Author:** AI Assistant  
**Reviewers:** TBD
