# 循環依賴解決方案說明

## 問題分析

### 原始循環依賴

```
IEffect → CombatContext → IResourceRegistry → IEffect
```

具體來說：

1. **IEffect** 的方法需要 `CombatContext` 作為參數
2. **CombatContext** 包含 `IResourceRegistry` 作為成員
3. **IResourceRegistry** 需要管理 `IEffect` 實例

這形成了一個循環依賴鏈。

## 解決方案：依賴倒置原則 (Dependency Inversion Principle)

### 實施步驟

#### 1. 創建 ICombatContext 介面

```typescript
// combat.context.interface.ts
export interface ICombatContext {
  readonly eventBus: EventBus
  readonly rng: CombatRandomGenerator
  readonly registry: IResourceRegistry

  // 方法簽名
  getEntity(id: string): IEntity | undefined
  addEntity(entity: IEntity): void
  removeEntity(id: string): void
  getAllEntities(): readonly IEntity[]
  getEntitiesByTeam(team: IEntity['team']): readonly IEntity[]
  getCurrentTick(): number
  incrementTick(): void
  resetTick(): void
}
```

#### 2. CombatContext 實現介面

```typescript
// combat.context.ts
export class CombatContext implements ICombatContext {
  // 具體實現
}
```

#### 3. IEffect 使用介面而非具體類

```typescript
// effect.model.ts
import type { ICombatContext } from '../../../context' // 使用介面

export interface IEffect {
  onApply(character: ICharacter, context: ICombatContext): void
  onRemove(character: ICharacter, context: ICombatContext): void
  onTick?(character: ICharacter, context: ICombatContext): void
}
```

## 為什麼這樣能解決循環依賴？

### 依賴方向變化

**之前（循環）**：

```
IEffect ──→ CombatContext (具體類)
            ↓
      IResourceRegistry
            ↓
        IEffect (循環！)
```

**之後（單向）**：

```
IEffect ──→ ICombatContext (抽象介面) ←── CombatContext (實現)
                                              ↓
                                        IResourceRegistry
                                              ↓
                                          IEffect
```

### 關鍵差異

1. **抽象 vs 具體**
   - IEffect 現在依賴於 `ICombatContext` **介面**（抽象）
   - 而不是 `CombatContext` **類**（具體實現）

2. **編譯時 vs 執行時**
   - 介面只是類型定義，在編譯時不會創建實際的依賴
   - TypeScript 的介面在編譯後會被移除
   - 只有在執行時才會注入具體的 CombatContext 實例

3. **依賴倒置**
   - 高層模塊（IEffect）不再依賴低層模塊（CombatContext）
   - 兩者都依賴於抽象（ICombatContext）

## 是否真的改進了？

### ✅ 是的，有以下改進：

#### 1. **打破了強耦合的循環**

- IEffect 不再直接依賴 CombatContext 的實現細節
- 只依賴於契約（interface）

#### 2. **提高了可測試性**

```typescript
// 測試時可以輕鬆 mock ICombatContext
const mockContext: ICombatContext = {
  eventBus: mockEventBus,
  rng: mockRng,
  registry: mockRegistry,
  // ...其他方法的 mock
}

// 不需要創建完整的 CombatContext 實例
effect.onApply(character, mockContext)
```

#### 3. **增強了靈活性**

- 可以有多個 CombatContext 的實現
- 例如：MockCombatContext、TestCombatContext、ReplayCombatContext

#### 4. **遵循 SOLID 原則**

- **D**: Dependency Inversion Principle（依賴倒置原則）
- **I**: Interface Segregation Principle（介面隔離原則）

## 技術細節

### TypeScript 的介面特性

```typescript
// TypeScript 介面是純類型層面的
// 編譯後會被完全移除
interface ICombatContext {
  /* ... */
}

// 編譯成 JavaScript 後：
// (介面消失，沒有實際代碼)
```

### 依賴圖對比

**編譯時依賴（TypeScript）**：

```
IEffect.ts ──→ ICombatContext.ts (只是類型)
CombatContext.ts ──implements──→ ICombatContext.ts
```

**執行時依賴（JavaScript）**：

```
effect (運行時對象) ←── context 注入 (運行時對象)
```

## 其他考慮

### 是否還有其他解決方案？

#### 方案 2: Event-Driven（事件驅動）

```typescript
// 不直接依賴 context，而是通過事件通信
effect.onApply((character) => {
  eventBus.emit('effect:applied', { character, effect })
})
```

- **優點**: 完全解耦
- **缺點**: 難以追蹤，過於複雜

#### 方案 3: Dependency Injection Container

```typescript
// 使用 DI 容器管理依賴
container.register('context', CombatContext)
const effect = container.resolve(Effect)
```

- **優點**: 更專業的 DI
- **缺點**: 增加複雜度，需要額外的庫

### 為什麼選擇介面抽象？

1. **簡單直接**: 不需要額外的庫或複雜的架構
2. **TypeScript 原生支持**: 充分利用語言特性
3. **保持代碼清晰**: 依賴關係一目了然
4. **性能無損**: 編譯後介面會被移除

## 總結

**問題**: 循環依賴 `IEffect → CombatContext → IResourceRegistry → IEffect`

**解決**: 將 `CombatContext` 抽象為 `ICombatContext` 介面

**效果**:

- ✅ 打破循環依賴
- ✅ 提高可測試性
- ✅ 增強靈活性
- ✅ 遵循 SOLID 原則
- ✅ 保持代碼簡潔

**結論**: 這是一個有效且優雅的解決方案，既解決了技術問題，又改善了架構設計。
