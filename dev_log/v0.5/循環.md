Collecting workspace information這是一個非常經典的架構問題。在 TypeScript 中，因為 `import type` 的存在，介面之間的循環依賴通常是可以被編譯器接受的（只要不涉及運行時的值）。但在嚴格的架構設計（如 Clean Architecture）或遷移到強型別語言（C#/Java）時，這確實是一個需要解決的設計缺陷。

問題的核心在於：**高層策略（Domain/Logic）依賴了低層實作（Context/Infra）的具體位置**。即使你引用的是介面，如果該介面定義在與實作相同的層級或模組中，很容易因為 Barrel File (index.ts) 的導出而意外引入具體類別，形成循環。

### 最佳解決方案：依賴倒置原則 (DIP) 與 共享核心 (Shared Kernel)

要徹底解決這個問題，我們需要將「介面定義」從「實作層」完全剝離，移入「領域層」的核心位置。

**核心概念：**

1.  `ICombatContext` 和 `IResourceRegistry` 不應該屬於 context 或 infra 層的定義，它們應該是 **Domain 層定義的契約 (Contract)**。
2.  Domain 層定義它需要什麼（介面），而 Context/Infra 層負責滿足這些需求（實作）。

### 實作步驟

我建議在 domain 下建立一個 `shared` 或 `contract` 目錄，專門存放這些核心契約。

#### 1. 移動並定義核心介面

將 `ICombatContext` 和 `IResourceRegistry` 移動到 `domain/shared/interfaces`。這樣 `IEffect` (Domain) 就只需要依賴 Domain 內部的契約，而不需要向外依賴。

```typescript
import type { IEffect } from '../../effect/models/effect.model'
import type { IUltimateAbility } from '../../ultimate/ultimate.ability.interface'
import type { Equipment } from '../../item/models/equipment.model'

/**
 * Moved from infra/resource-registry to domain/shared/interfaces
 * This is now a Domain Contract (Port).
 */
export interface IResourceRegistry {
  registerEffect(effect: IEffect): void
  unregisterEffect(id: string): void
  getEffect(id: string): IEffect | undefined
  hasEffect(id: string): boolean

  registerUltimate(ultimate: IUltimateAbility): void
  getUltimate(id: string): IUltimateAbility | undefined

  registerEquipment(equipment: Equipment): void
  // ... other methods
}
```

```typescript
import type { EventBus } from '../../../infra/event-bus'
import type { CombatRandomGenerator, IEntity } from '../../../infra/shared'
import type { IResourceRegistry } from './resource-registry.interface'

/**
 * Moved from context/ to domain/shared/interfaces
 * This is now a Domain Contract.
 */
export interface ICombatContext {
  readonly eventBus: EventBus
  readonly rng: CombatRandomGenerator
  readonly registry: IResourceRegistry

  getEntity(id: string): IEntity | undefined
  addEntity(entity: IEntity): void
  removeEntity(id: string): void
  getAllEntities(): readonly IEntity[]
  getEntitiesByTeam(team: IEntity['team']): readonly IEntity[]

  getCurrentTick(): number
  incrementTick(): void
  resetTick(): void
}
```

#### 2. 修正 `IEffect` 與 `ICombatHook` 的依賴

現在，修改 `IEffect` 和 `ICombatHook`，讓它們指向新的 Domain 介面，而不是 Context 層。

```typescript
import type { ICharacter } from '../../character/interfaces/character.interface'
// Change import to the domain shared interface
import type { ICombatContext } from '../../shared/interfaces/combat-context.interface'

export interface IEffect {
  readonly id: string
  readonly name: string
  onApply(character: ICharacter, context: ICombatContext): void
  onRemove(character: ICharacter, context: ICombatContext): void
  onTick?(character: ICharacter, context: ICombatContext): void
}
```

```typescript
// Change import to the domain shared interface
import type { ICombatContext } from '@/modules/combat/domain/shared/interfaces/combat-context.interface'
import type { DamageEvent } from './damage.event.model'

export interface ICombatHook {
  beforeDamageCalculation?(event: DamageEvent, context: ICombatContext): DamageEvent
  onHitCheck?(event: DamageEvent, context: ICombatContext): DamageEvent
  onCritCheck?(event: DamageEvent, context: ICombatContext): DamageEvent
  onDamageModify?(event: DamageEvent, context: ICombatContext): DamageEvent
  onDefenseCalculation?(event: DamageEvent, context: ICombatContext): DamageEvent
  beforeDamageApply?(event: DamageEvent, context: ICombatContext): DamageEvent
  afterDamageApply?(event: DamageEvent, context: ICombatContext): void
}
```

#### 3. 修正實作層 (Context & Infra)

最後，讓具體的 `CombatContext` 和 `InMemoryResourceRegistry` 實作這些 Domain 介面。

```typescript
// ...existing code...
import type { ICombatContext } from '../domain/shared/interfaces/combat-context.interface'
import type { IResourceRegistry } from '../domain/shared/interfaces/resource-registry.interface'

export class CombatContext implements ICombatContext {
  // ...existing code...
}
```

```typescript
// ...existing code...
import type { IResourceRegistry } from '../../domain/shared/interfaces/resource-registry.interface'

export class InMemoryResourceRegistry implements IResourceRegistry {
  // ...existing code...
}
```

### 為什麼這樣能解決問題？

1.  **打破實作依賴**：原本的循環是因為 `IEffect` -> `Context (Class)` -> `Registry` -> `IEffect`。現在 `IEffect` 只依賴 `ICombatContext (Interface)`，而這個 Interface 定義在 Domain 內部，完全不依賴外部的 `Context (Class)`。
2.  **符合 DIP**：高層模組（Domain）定義介面，低層模組（Context/Infra）實作介面。依賴箭頭全部指向 Domain。
3.  **C#/Java 遷移友善**：在強型別語言中，這通常對應於將介面放在 `Core` 或 Domain 專案中，而實作放在 `Infrastructure` 專案中。`Core` 專案不引用 `Infrastructure`，從而物理上杜絕了循環依賴。

### 關於介面間的循環 (Interface Loop)

你可能會發現 `ICombatContext` 引用 `IResourceRegistry`，而 `IResourceRegistry` 引用 `IEffect`，`IEffect` 又引用 `ICombatContext`。

這在 **介面層級** 的循環是完全正常的（例如 Parent 介面有 Child，Child 介面有 Parent）。只要它們都在 Domain 層（或透過 `import type` 引用），且不涉及具體類別的實例化或繼承，這在任何語言（包括 C# 和 Java）中都是合法的設計。真正的毒藥是將「具體類別」捲入這個循環中，而上述方案透過將介面移
