# **戰鬥狀態機制設計報告：堆疊、刷新與聚合**

這份報告分析了四種核心戰鬥狀態（冰緩、中毒、聖火、充能）的設計機制，旨在在深度數值（Stat RPG）與自動對戰（Auto-Battler）遊戲中實現複雜而平衡的狀態效果。

## **狀態效果總覽與機制核心(來自GPT給的建議)**

### **核心設計原則**

所有效果都採用**獨立實例（Independent IEffect Instance）**的邏輯，但根據效果的類型分為兩大管理模式：

1. **時效型（獨立計時）：** 每個實例獨立計時，時間到期即自然消亡。適用於控制與單次能量爆發。
2. **持續型（統一刷新）：** 每個實例雖然獨立，但其持續時間會被任何新的同類型效果**統一刷新**，確保效果連貫。適用於持續傷害/治療。

### **玩家角度敘述：戰鬥體驗與回饋**

| **效果**                | **類型**      | **玩家感受到的機制**                                                                                                                                    | **戰鬥回饋**                                                                           |
| ----------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| **❄️ 冰緩 (CHILL)**     | 減速 Debuff   | **「層數越多，敵人越慢。」** 每次攻擊都會獨立計算持續時間，即使同時受到多個冰緩來源攻擊，每個攻擊的冰緩實例會在時間到後自然消失，使總減速效果逐漸消退。 | 敵人身上的冰霜特效會隨著層數堆疊變得更明顯，其攻擊動畫和頻率會有明顯下降。             |
| **💀 中毒 (POISON)**    | 持續傷害 DoT  | **「毒藥一旦沾上，就難以根除。」** 每次中毒都會刷新敵人身上所有中毒的持續時間。只要不斷上毒，就能維持極高的持續傷害輸出。                               | 敵人的血條會持續跳出綠色真傷數字，且效果不會隨著時間而自然減少，除非攻擊來源停止。     |
| **🔥 聖火 (HOLY FIRE)** | 持續治療 Buff | **「疊層累積力量，爆發神聖光芒。」** 每次獲得聖火都會刷新所有聖火的持續時間。治療量隨層數增加，且達到 10 層時會觸發額外的大幅度治療增益。               | 角色身上有金黃色的光芒流動。當達到 10 層閾值時，光芒會瞬間爆發，治療數字會變大且閃爍。 |
| **⚡ 充能 (CHARGE)**    | 能量增益 Buff | **「爆發前的蓄力。」** 攻擊時獲得等同於總層數的能量。單次充能有時限，時間到期會自然消亡，鼓勵玩家在短時間內集中爆發能量以釋放終極技能。                 | 角色身上有藍白電流竄動。攻擊時，終極技能的能量條會快速跳動。                           |

---

## **開發者視角：導入既有架構與重構建議(來自GPT給的建議)**

### **如何導入既有架構 (Existing Architecture Integration)**

既有的 CombatEngine 包含 CombatContext、TickerDriver、TickActionSystem 和 IEffect 介面，這些都是實現新機制的良好基礎。

### **1. 新增 Effect 類型與屬性**

- **IEffect 介面擴展：** 確保 IEffect 實例中包含：
- sourceId: string：施加者 ID，用於統計和傷害歸屬。
- currentLayers: number：該實例當前所擁有的層數（例如 A 一拳打出的 5 層）。
- expirationTick: number：該實例的預計結束 Tick 數。
- effectType: 'CHILL' | 'POISON' | 'HOLY_FIRE' | 'CHARGE'：用於判斷執行哪種管理模式。

### **2. 核心控制器模組 (Controller Modules)**

為了實現「統一刷新」和「閾值聚合」，必須引入新的單例服務：

- **EffectAggregator：** 負責追蹤每個角色的所有效果的**總層數**。
- getAggregatedLayers(targetId, type): 回傳 C 角色身上所有 CHILL 實例的 currentLayers 總和。
- applyFinalStatMod(character): 根據總層數，計算並應用最終的屬性修正值（例如總冰緩層數造成的攻速降低）。
- **EffectRefresher：** 專門處理統一刷新邏輯。
- 當施加新的 POISON/HOLY_FIRE 時，EffectRefresher 會遍歷目標身上所有同類型實例，並將其 expirationTick 設為新的、更長的 Tick 數。

### **3. Ticker Action System 應用**

- **TickActionSystem** 必須在每個 Tick 執行以下動作：
- **移除時效型效果：** 檢查所有 CHILL/CHARGE 實例，如果 currentTick > expirationTick，則呼叫 context.removeEffect()。
- **執行持續型傷害/治療：** 檢查 POISON/HOLY_FIRE 實例，並呼叫 DamageChain 或 HealingSystem 處理傷害/治療。

### **重構建議 (Refactoring Recommendations)**

為了讓既有的 IEffect 系統能支援這種複雜的堆疊與聚合邏輯，需要進行以下重構：

### **1. 將 IEffect 分離為「Instance」與「Defintion」**

- **舊：** IEffect 介面可能包含效果定義和當前狀態。
- **新：**
- **EffectDefinition：** 靜態配置，定義效果名稱、上限（81 層）、單層效果數值等。
- **EffectInstance：** 運行時實例，包含 sourceId、currentLayers、expirationTick。
- **優勢：** 清晰分離配置與運行時狀態，使多個實例共享同一個邏輯定義。

### **2. 建立 CharacterStateManager**

- **問題：** 既有架構可能將 IEffect 實例直接儲存在 ICharacter 類別中。
- **重構：** 創建一個獨立的 CharacterStateManager 類別或服務，專門管理角色的所有狀態。
- this.context.states.get(characterId)
- 這個 Manager 內含 EffectAggregator 的實例，可以快速計算出角色的**總體狀態屬性修正**（例如：最終攻速、最終能量獲取率）。
- **優勢：** 將複雜的聚合邏輯從 ICharacter 本身分離，提高模組化。

### **3. 處理狀態修正計算（Stat Correction）**

- **舊：** 傷害計算可能直接依賴 ICharacter 的 attackDamage 屬性。
- **重構：** 在 DamageChain 的 **PreDamageCalculationStep** 之前，引入一個新的步驟：
- **ApplyEffectCorrectionStep：** 在此步驟中，引擎呼叫 EffectAggregator 計算**總冰緩層數**，並將這個減速百分比應用到目標角色的**當前攻擊速度**計算中，確保傷害計算使用的屬性是最新的。
- **優勢：** 確保狀態效果在數值層面得到及時反映，而不依賴於 Tick 的先後順序。

---

## 我個人想法(也只是初步構思):

### 關於重構

- 原本的疊層機制 stackable effect 我不確定要不要刪掉然後重構效果體制
- 效果關心很多東西，但我沒確定要幹嘛
- 我想重新定義效果與其系統架構
- 畢竟我這是輕量級的 auto-battler，不是重度的 stat rpg

#### 我的第二次構思(你提出建議或幫我想我沒想到的情況，讓我trade-off或你來trade-off)

- TickActionSystem 依然保持 每 Tick 去觸發該 Tick 下的效果
- 1 個 Character 身上可以有多個效果同時存在
- 效果一律只有存在一個，例如 300 layers 的 Chill 效果，而不是 3 個 100 layers 的 Chill 效果
- 有些效果實作類有 layer 特性
- 效果觸發後減少機制是可選的，是 onTick 的衍伸任務，有些效果不用這功能。
- 目前的作法是 當有人被特殊攻擊添加 new ChillEffect(1), 下次又是這樣。但我相信有很多實作方式更符合我的專案需求對吧?
- #### 我的第三次構思
  Sonnet給的核心設計原則
  Single Instance Per Type: 每個 Character 每種效果類型只有一個實例
  Layer-Based Stacking: 透過 addLayers() 累加層數而非創建新實例
  Strategy-Based Decay: 衰減邏輯可抽換,方便實驗
  Manager-Controlled Creation: EffectManager 負責合併/創建邏輯
- 我也有想法:
  - 那麼效果應該被修飾嗎?業界會這樣做嗎?
  - 我舉個例子，有個聖物的特效是 施放詛咒 敵人受到的 poison 傷害 x2 觸發三次後消除詛咒
  - 我舉個例子，有個聖物的特效是 我受到的 chill debuff 不會遞減持續 xxxx tick,同時 我造成的 chill debuff layers 這段期間也能造成 poison 這種複雜規則
  - 你的 1 character 1 effect instance 的設計，會不會讓這些聖物特效變得很難實作?還是這不是問題?
  - 你的設計應該不會影響其他功能吧? 例如我改 effect 底層原理，連 協跳與戰鬥計算邏輯都不會受影響吧?

### 關於 Poison

- 造成 1:1 N layers true damage
- 間隔 n tick 發動 / tick:start 觸發 / 觸發後 降低 n% layers
- 無上限
- 觸發做成策略，我想實驗不同觸發與降低機制的平衡性

---

### 關於 Chill

- 造成 對目標施加 n layers chill 的 modify (會減緩 attack speed)
- 間隔 n tick 發動 / tick:start 觸發 / 觸發後 降低 n% layers
- 無上限
- 觸發做成策略，我想實驗不同觸發與降低機制的平衡性

---

### 關於 Holy Fire

- 間隔 n tick 發動 / tick:start 觸發 / 觸發後 降低 0% layers (不會自然消失)
- 上限 100 layers / 效果本體沒任何用途，依賴聖物與裝備按照 layers 觸發對應效果
- 是給聖火流派用的

---

### 關於 Charge

- 就是 Chill 的正向版本
- 造成 對目標施加 n layers charge 的 modify (會加快 attack speed)
- 但依然要分離邏輯別共用 Chill 的邏輯
