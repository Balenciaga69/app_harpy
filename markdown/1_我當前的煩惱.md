## 主要痛點與問題

### 效果系統架構問題

#### EffectCalculator 違反開放封閉原則

- 每新增一種效果，都必須修改 `calculateTotalModifier`，不利於擴展。
- 建議將屬性計算邏輯下沉到每個 Effect 實體，由 Effect 自己計算修飾，EffectCalculator 只負責聚合。

#### 策略模式不完整

- 新增效果時需修改 EffectHandler，違反單一職責原則，且複雜效果邏輯難以測試。

#### 效果組合邏輯分散

- 例如「冰傷害能感電敵人」這類效果組合，需修改 DamageHandler，導致邏輯分散且難以維護。
- Effect 模型過於簡單，無法承載複雜狀態（如「物理傷害反彈為火傷害」、「閃避值轉為護甲」等）。

### 其他架構問題

#### 缺乏複雜條件觸發的 Hook 點

- 目前架構難以支援像「吸血」、「反彈」、「低血量觸發」等多步驟、條件式效果。
- 缺少責任鍊（Chain of Responsibility）分解，導致效果鏈難以擴展。

#### 全域狀態存取導致高耦合

- Handler 類直接存取全域 Store（如 `useXXXStore.getState()`），造成模組間高度耦合，降低維護性。

#### Tick 效果分散處理

- 聖火治療、毒傷害等 Tick 效果分散在各處，建議統一由 Ticker 調度。

#### 傷害計算流程不支援插入修改器

- 所有傷害直接計算，無法插入額外的修飾或攔截器，限制了玩法的靈活性。

#### 缺乏多步驟效果鏈的架構

- 難以實現「冰雷攻擊 → 反彈 → 回血 → 強化」這種多步驟連鎖效果，需要更靈活的架構設計。

#### 架構重構建議

- 建議全面重構 DamageHandler 與 EffectCalculator，並引入責任鍊模式、策略模式、狀態模式，提升擴展性與維護性。

---

### 可保留的基礎架構

#### 觀察者模式

- 適合處理遊戲中連鎖反應（如感電觸發增傷），可繼續保留。

#### Tick-based 循環

- 放置遊戲標準架構，運算高效且結構清晰，建議保留。
