---
applyTo: '/*.ts, /*.tsx, /*.js, /*.jsx'
---

### 關於你的回應

- 我發現你有個壞習慣, 當你改完之後你會產生一堆不必要的 markdown 說明你自己改動甚麼, 但這東西壓根不會有人看, 也不會有人 care
- 所以從現在開始, 除非我特別要求, 否則在對話上下文回應就好, 完全沒必要在產出你改動啥的 md 檔案

### 關於 Markdown

- 繁體中文優先, 只使用 Bullet Points 與 Heading 結構
- 不會有任何代碼, 只有文字且易讀而非過度學術技術派

### 關於代碼

- 堅守原則
  - 乾淨代碼
  - 低耦合
  - 高內聚
  - 可維護性強
  - 易讀性高（優先考慮 AI 解析需求，減少跨檔案跳轉以提升相關內容內聚）
  - 命名有意義
  - KISS, YAGNI, DRY 原則很注重
  - 拒絕過度抽象與過度設計：抽象應該以當前問題為導向，越簡單越好
  - 少即是多：抽象往往是複雜度的來源，優先考慮直接、明確的實作
  - 語言中立：設計應能被 Python/TS/Go/Java 等語言無痛接軌
  - 依賴即毒藥：視外部依賴為有成本的資源，使用介面隔離並限縮依賴範圍
  - 拒絕分散大量檔案：一個類型一份檔案，優先內聚相關內容
- 為了 AI 方便
  - 明確化依賴、副作用與邊界條件：防止 AI 自行假設，所有的依賴、副作用、邊界條件都必須明確化,
  - 代碼自身不可隱藏意圖
  - 檔案大小限制：500行以上的單一檔案需拆分成多個檔案，200-500內屬於健康的範圍
  - 防腐與單一入口：非常重要，使 AI 不會圖方便跨越防腐層直接操作內部實現
  - 過度的乾淨會使 AI 上下文斷裂, 來回檢索會產生幻覺
  - 命名不可簡約或多內容趨同, 會導致語意不清或丟失
- 更佳實踐
  - 善用簡潔的設計模式（非為模式而模式）
  - 在寫方法與類別的時候要預先想好, 這東西是要被單元測試的 - 但你不用先寫測試
  - 遵循 SOLID 原則 - 尤其是單一職責原則最重要，但不要為了分層而拆掉流程的清晰度
  - 物件關係不應形成循環依賴 - 依賴應該是單向的
  - 使用明確的介面來解耦實作與測試，保證核心邏輯可以用極簡 Mock 驗證
  - 優先以靜態類型與靜態分析工具來保證合約，讓編譯器替你找錯誤
  - 強烈偏好簡單且可理解的實作，而非追求工業流程般的統一風格或過度抽象
  - 如果你要寫 markdown 請以中文為主
  - 我偏好業界最佳實踐, 已被驗證過成熟的方案, 而非創新或實驗性質的東西
  - 我在命名以及架構上偏好使用通用語言, 就是最接近業界標準的作法與定義
  - 命名使用約定俗成的詞彙, 且謹慎選擇專業術語
  - 當你建立 (Create)、更新 (Update)、刪除 (Delete) 時也要關注是否有連動的檔案或 spec.md

### 我認為糟糕的代碼

- 命名一堆單字組合而成
- 函數或方法的參數一大堆
- 沒用到的代碼也不刪除
- 大量 nested structure,loops, conditionals
- 沒有型別或者型別在調用途中被破壞
- 一份資料夾十個檔案
- 有副作用無法追查
- 換個語言或框架或套件這個功能就廢掉了
- 單元測試不能準確測試這段代碼
- 過度設計 - 設計是為了解決現在的問題而不是未來的問題
- 偷偷使用全域或單例
- 魔法數字和魔法字串
- 一個檔案或類別幾千行, 它什麼都管
- 過度抽象，為了模式而模式，導致使用成本大於收益
- 為簡單 CRUD 拆出 5 個檔案、3 個介面、2 個 DTO 去轉型（拒絕為架構而架構）
- 函數參數無止境膨脹、邏輯與 UI 高度耦合、以及大量不可測試的 if-else 嵌套
- 高層次與低層次內容混合在一起(業務流程與細節實作、數據轉換細節耦合)
- 已成形的功能中發現大量重複代碼，或可抽象化的邏輯卻依然 Repeated

### 關於註解

- 註解的主要用途是作為 AI 檢索加速, 以及人類可讀性輔助
- 開發的時候不要添加註解, 我偏好自己先手動寫註解, 由 @comment 指令後再由 ai 修正或產生新註解
- AI 偏好的註解:
  - Docstring
  - 一致的詞彙
  - 使用業界標準術語
  - 提升可檢索性的描述
  - 拒絕過於簡略的註解
- 即使代碼很直觀，也應保留類別與重要方法的"單行描述", 這能顯著提升 Agent 在進行 RAG 時的準確度
- 修改或重構代碼時務必更新相關註解以保持一致性
- 幫助開發者理解意圖，而非陳述代碼做了什麼
- 積極使用 Docstring 描述功能與類型自我描述
- 如果註解出現在每一行，要確認是否應該合併為方法級別的 Docstring。
- 如果方法複雜或明顯需要協調,則需要明確的邊界與前置條件
- 不用寫 param, return, throw 等註解, 這對 AI 沒什麼幫助
- 需要 單行功能描述
- [可選]: 說明副作用, 邊界, 依賴等等
- [可選]: 若規則複雜, 可簡單說明業務邏輯

### TypeScript 檔案與資料夾與物件命名規範

檔案名稱規範

- React 元件: PascalCase (例如 UserProfile.tsx)
- 類別、抽象類別: PascalCase (例如 UserProfile.ts)
- 工具類、輔助類、公用類: PascalCase (例如 DataFetch.ts)
- 介面、型別、列舉: PascalCase (例如 IUserProfile, CharacterInformation.ts)

物件內部命名規範

- 類別: PascalCase (例如 UserProfile)
- 類別介面: I + PascalCase (例如 IUserProfile)
- 資料介面或型別別名: PascalCase (例如 UserID)
- 列舉: PascalCase (例如 UserRole)
- 常數: UPPER_SNAKE_CASE (例如 MAX_RETRY_COUNT)
- 工具函數、輔助函數、公用函數: camelCase (例如 fetchData)

### 本專案限定內容

- 我們做邏輯 (非 UI) 的內容一律以未來邏輯內容能被 CSharp、Python、Go 等語言無痛轉移為優先考量
- 再遷移時候不會煩惱依賴某套件, 或者耦合某個框架
- 我們使用了模組化架構來做專案結構
- 專案理論上可以被拆成前端與後端與獨立微服務之間不該有耦合 (除非共享契約與邏輯)
- 我們視依賴為有成本的資源：依賴引入前先評估替代方案與介面隔離策略
- 依賴應透過介面抽象，不允許直接將外部實作滲透到 domain 核心
- 優先使用靜態分析、型別系統與小量單元測試來保證行為，而非大量整合測試來掩蓋設計缺陷
- 在可能的情況下，核心業務邏輯能用極簡的 Mock 就能測試通過
- 拒絕為了架構而架構：如果拆分、抽象帶來的成本高於收益，就回到簡單實作
- 我們使用的 TS 套件包括
- 純 TS 套件
  - mitt
  - chance
  - seedrandom
  - nanoid
- 與瀏覽器或 React 互動的 TS 套件
  - heroui/react
  - tailwindcss
  - localforage
  - zustand

#### 模組內的開發守則

- 因為我安裝了 eslint-plugin-boundaries
- 我要讓內部遵循單向依賴規則 - 箭頭永遠指向內層
- 我將模組分成多層結構, 同時若模組規模過大, 我會在模組內再細分 sub-modules
- domain/app/infra
  - domain 核心概念幾乎全部分佈在此
- 聚合根, 實體, 值物件, 領域服務, 領域事件
- domain 層是核心價值所在, 必須保持其純粹性, 不被任何外部技術細節污染
- 明確要求所有值物件都必須是不可變的
  - app 定義執行流程, 協調實體層
- 應用程式服務, 儲存庫介面, 服務介面
  - 這層將外部的伺服器技術, 與內部的邏輯連接起來
- 儲存庫實作, 服務實作, 呈現器
  - infra 這層包含所有技術骨架
- 網路框架, 配置依賴注入, 日誌系統, 監控系統
  - 當您有 A、B 兩個不同限界上下文需要合作, 防腐層 (ACL) 通常是必需的
- 避免污染核心模型, 隔離外部系統的變動, 強制單向依賴
- 下游上下文應該建立防腐層來保護自己免受上游變化的影響
  - 內層絕不能直接引用外層的實作, 若需要外層的能力必須依賴外層定義的介面
- 介面是非常重要的, 這樣我們才能解耦與替換實作與測試
- 其餘地方不會有任何 index.ts

### 關於如何閱讀

- .github\faq: 放了一些常見問題解答
- src: 主要程式碼
- src\shared\result\Result.ts 這是 Result<T,E>
- src\data: 放了遊戲設定的靜態配置資料(給設計師調整的地方)
