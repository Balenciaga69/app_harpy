# 詞綴系統問題

## 1. 詞綴層次結構與轉換邏輯的模糊性

### 問題

AffixTemplate（靜態藍圖）定義觸發條件 + 行為類型 + 參數，但轉換為 AffixInstance（運行時實例）時，如何處理「具體數值」（Rolled Value）？

StatModifier（純數值修飾）如何從 AffixInstance 解析？

文檔提及「影響屬性、運算方式（Added, Multi, More）」，但缺乏具體轉換規則：

- 一個 Affix 如何衍生多個 Modifier？
- 條件觸發如「低於 50% 魔力」如何實作？

### 衝突點

- 與 ailment.blueprint.md 整合時，Affix 可附加狀態（如冰緩）
- 但狀態實例（currentStack, currentDuration）如何與 StatModifier 區分？
- Affix 轉換為 Modifier 時，狀態效果是否也需解析為數值修飾？

### 軟體層面風險

這可能導致實作時邏輯混亂，屬性聚合系統難以統一處理

### 建議

補充轉換管道（Pipeline）設計，定義明確的解析函數：

```typescript
// 例示
parseAffixToModifiers(affixInstance): StatModifier[]
```

確保條件觸發邏輯與事件系統（combat.blueprint.md）整合，避免硬編碼

---

## 2. Affix 系統「純粹性」的污染 ⚠️

### 問題陳述

你反覆強調 AffixTemplate 不關心：

- 出現時機
- 擁有者
- 地點

**但實際上 AffixTemplate 內包含：**

- 觸發條件（eventType）
- 行為（APPLY_STATUS / MODIFY_STAT）
- 生效條件（如 HP < 50%）
- Tags
- 生成限制（等級、章節）

這已經不是「純藍圖」，而是「半生成規則 + 半行為描述」

### 真正的衝突

你同時存在三個地方在「決定 Affix 是否能作用」：

1. **AffixTemplate** 定義生效條件
2. **AffixPool / Generator** 定義是否能被抽中
3. **Context（Run / Difficulty / Endless）** 動態修改可出現性

### 責任混亂

這導致無法明確回答：

- 哪一層負責「是否能出現」？
- 哪一層負責「是否能生效」？
- 多層規則衝突時誰優先？

### 解決方案

**強制切一刀：**

AffixTemplate 只定義「如果它被啟用，會做什麼」

所有出現決策集中到一個 **AffixAvailabilityPolicy / RuleSet**（生成層）：

- 章節 / 等級限制
- 出現模式（Boss only / Endless only）
- 禁用規則
- 動態條件

```typescript
// 偽代碼結構
interface AffixTemplate {
  id: string
  // 行為定義（保持純粹）
  trigger: EventType
  effects: Effect[]
  conditions: Condition[]
}

interface AffixAvailabilityPolicy {
  // 出現決策（獨立管理）
  levelRange: [min, max]
  chapters: ChapterId[]
  roleRestrictions: EnemyRole[]
  contextRules: ContextualRule[]
  exclusions: AffixId[]
}
```

**好處：**

- AffixTemplate 真的純粹了
- 生成規則集中，易於維護與調試
- 擴展新出現條件無需修改 Template

---

## 3. 詞綴與狀態系統的邊界模糊 🔄

### 問題：Status 其實是「另一種 AffixInstance」

你嘴上說它們是不同系統，但從行為來看：

- 有來源 ✓
- 有數值 ✓
- 影響屬性 ✓
- 影響行為 ✓
- 差別只剩「是否有 duration」

**這會產生兩個實際問題：**

#### 問題 3.1：雙重聚合來源

你現在有：

- 裝備 → Affix → StatModifier
- 狀態 → Status → StatModifier

但誰負責最終一致性？

- Status Tick 後改變 Stat
- 屬性聚合階段又重新計算
- 那 Status 的影響是：
  - 永久寫回？
  - 還是每 Tick 重新套？

**目前描述是模糊的**

#### 問題 3.2：裝備改變異常狀態行為

你說：

> 裝備、遺物可改變異常狀態計算方式

那請問：

- 是 Affix 改變 Status Template？
- 還是改變 Status Instance 行為？
- 還是插手 Status System 的計算？

這三個選項架構差異極大，目前你沒有選清楚

### 建議一個乾淨解法 ✨

把 Status 明確降級成：

> 「有 duration 的 Modifier 容器」

也就是：

```typescript
interface StatusTemplate {
  id: string
  // 只包含數值修飾 + 時間規則
  modifierTemplate: ModifierTemplate
  durationRule: DurationRule
}

interface StatusInstance {
  // 運行時只跟蹤進度
  modifierInstance: ModifierInstance
  timer: DurationTimer
}
```

**這樣：**

- 屬性聚合永遠只吃 Modifier
- 不再有「狀態是否直接改 stat」的歧義
- Affix / Status 只是「來源不同」

**結果：**
這會讓你整個戰鬥層瞬間清爽很多

---

## 4. 生成系統與池表的耦合與動態調整

### 問題

詞綴生成流程依賴詞綴池表（Affix Pool Table），但 generator-weight.blueprint.md 引入動態權重修飾符（e.g., Run Context 中的 JSON 陣列）

**這可能造成：**

- 池表靜態定義 vs 動態調整的衝突
- 權重調整後的 Roll 破壞平衡風險
- 難度係數（difficulty.blueprint.md）影響生成，但未說明如何與池表整合

### 空白

無盡模式（endless.blueprint.md）中敵人加入特殊 Affixes，但：

- 生成邏輯如何區分「僅此階段出現」？
- 池表是否需支援階段標籤？

### 軟體層面問題

動態權重若存於 Run Context，可能導致：

- 狀態膨脹
- 影響序列化/反序列化效能

**建議：** 引入快取層或預計算邏輯

---

## 5. 角色與敵人作為 Unit 的不一致性

### 問題

character.blueprint.md 與 creature.blueprint.md 皆稱角色/敵人為 Unit

**但存在根本差異：**

| 面向       | 角色                 | 敵人                         |
| ---------- | -------------------- | ---------------------------- |
| 成長方式   | 裝備/遺物聚合        | 模板 + 生成參數決定          |
| Affix 來源 | 多個（裝備、遺物等） | 應該「模板靜態」（但違反了） |
| 滾動數值   | 有（rolled values）  | 「不會有 rolled 的問題」     |

### 關鍵衝突

**affix.blueprint.md 允許 Affix 附加到敵人**（e.g., 無盡模式特殊 Affixes）

**這與「敵人模板死」的設計矛盾**

若敵人有動態 Affix，如何保持模板靜態？

### 設計混亂案例

level.blueprint.md 中敵人模板可擔任 normal/elite/boss，但 Affixes 疊加方式不同

若 Affix 可附加，則敵人實例需支持動態修改，但文檔強調敵人「不會有 rolled 的問題」

**這可能導致實作時被迫複製邏輯**

### 建議

**明確區分兩層：**

1. **模板級 Affix**（靜態定義於敵人模板）
2. **實例級 Affix**（動態附加，如無盡特殊效果）

**引入敵人生成器模組**，統一處理：

- 模板 + 參數
- 動態 Affix 附加
- 角色等級修正

避免 Unit 類型過於抽象導致測試困難

---

## 標記

- 核心問題：詞綴邊界不清
- 優先級：🔴 高 - 影響核心邏輯
- 相依模組：狀態系統、事件系統、屬性聚合、敵人生成
