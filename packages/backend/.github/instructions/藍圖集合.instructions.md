----
FileRelativePath: temp_github.txt
----
FileRelativePath: blueprints\affix.blueprint.md
# Affix（詞綴）
## 語意級（設計師閱讀）
### 詞綴的定義
Affix（詞綴）是靜態模板，描述遊戲中發生的效果與參數（如影響屬性、觸發行為、賦予狀態）。
模板不包含運行時邏輯，由生成層與運行時系統（事件系統、屬性聚合系統等）協作實現。
### 數值調整與難度係數
- Affix/Effect 數值會根據「難度係數倍率」進行調整。
- 生成 AffixInstance 時，會帶入當前關卡或遊戲進度的難度係數。
- 計算公式範例：
  - 最終數值 = 基底值 × 難度係數 × 詞綴倍率
- 例：基底 100，難度係數 30，詞綴倍率 0.9，則最終為 100 × 30 × 0.9 = 2700。
- 這種設計可讓同一模板在不同進度下產生不同強度，提升遊戲彈性與平衡。
### 詞綴的職責
詞綴模板（AffixTemplate）責任明確：
- 定義行為與基礎數值，保持純粹。
- 不關心持有者或堆疊規則（由載體決定）。
- 所有詞綴由物品模板或敵人模板預先綁定，無動態選擇、無權重、無 roll。
- 效果直接嵌入物品/敵人模板，啟動時全量附加。
### 誰關心 Affix
- 載體：物品、裝備、遺物、終極寶石（Ultimate Gem）。
- 系統：詞綴生成系統、狀態系統、屬性聚合系統、事件系統。
- 表現：賽前變數效果以狀態實例或屬性修飾符（StatModifier）注入。
### 常見問答
#### Q: 詞綴是什麼？
A: 靜態模板，定義效果與參數（ID、Tags、EffectTemplateId 等）。生成與運行時規則由其他系統處理。
#### Q: 修飾符是什麼？
A: 運行時純數值單元（Modifier / StatModifier），由 AffixInstance 與 EffectTemplate 解析產生，被屬性聚合系統使用（Add/Multi/More 等）。
#### Q: 詞綴實體（AffixInstance）如何生成？
A: 物品模板預定義詞綴列表 → 直接附加所有詞綴到物品實例 → 檢查排他/家族規則確保無矛盾 → 建立 AffixInstance 注入目標。
## 架構級
### 名詞定義統一
- AffixTemplate（詞綴模板）
  - 靜態藍圖，定義觸發條件、行為類型與參數
- AffixInstance（詞綴實體）
  - 物品模板綁定的詞綴實例，含 affixTemplateId、sourceId、metadata、uniqueCounter
- Modifier / StatModifier
  - 由 AffixInstance 與 EffectTemplate 解析的純數值修飾，用於屬性運算
### 詞綴層次與轉換
- Affix 屬戰鬥外靜態資源。
- 戰鬥時，Affix 轉換為 1..n 個 Modifier 並送入聚合系統。
- 轉換過程由專門的 EffectProcessor 負責，將 AffixInstance 與 EffectTemplate 解析為 StatModifier。
- 聚合系統維持穩定介面，不直接依賴轉換細節。
### 屬性聚合系統
聚合系統要點：
- 僅依賴 StatModifier，不直接認識 AffixTemplate 或 preCombat。
- 轉換器由上層注入，轉換 AffixInstance 與 EffectTemplate 為 ModifierInstance。
- 聚合系統維持穩定介面，便於擴充來源。
### 詞綴綁定結構
- 詞綴直接綁定在模板中：
  - 物品模板綁定：
    - itemTemplate.affixes = [affixId1, affixId2, ...]（無權重、無選擇）
  - 敵人模板綁定：
    - enemyTemplate.affixes（按難度模式不同可設定不同詞綴陣列）
  - 詞綴定義：
    - ID
    - Tags
    - EffectTemplateId
    - 運算方式（Add / Multi / More）
    - 生效條件
## 代碼級
### 詞綴生成流程
1. 物品/敵人模板預定義 affixes 陣列。
2. 實例化時直接讀取該陣列中所有詞綴。
3. 建立 AffixInstance 陣列並注入目標。
【無選擇、無權重、完全按模板決定。】
### EffectProcessor（效果處理器）
轉換詞綴效果的專門処理器，責任清晰：
- 作用：將 AffixInstance 與 EffectTemplate 解析為 StatModifier 或其他可執行的效果單元。
- 流程：讀取 EffectTemplate 定義 → 應用難度係數倍率 → 生成 ModifierInstance 並注入屬性聚合系統。
- 隔離：EffectProcessor 獨立於業務邏輯，易於測試與擴展。
- 復用性：同一 Processor 可被多個來源使用（Affix、Ultimate、Item 等）。
### 測試工具：上帝模式
提供「上帝模式」測試工具，具備功能：
- 自由選擇並附加任意詞綴組合到任何載體。
- 用於邊界測試與驗證。
- 正式環境套用 Context 規則以確保平衡。
### 設計原則
- 隔離依賴：Affix 生成涉及多系統，明確隔離避免隱性耦合。
- 轉換器介面：設計專責資料轉換的介面，不放業務規則。
- 事件驅動：多數條件由 EventSystem（OnAttack、OnUltimate、OnDeath、OnCast）實作。
- 狀態語義：狀態/層數、不可逆與堆疊需明確定義。
- 無狀態設計：AffixInstance 本身不持有「當前是第幾次攻擊」等運行時狀態，詞綴只負責查詢相關數值。狀態管理由系統層級（如事件計數器、屬性聚合系統）維護。
## 參考構思範例
- 賽前變數
  - 開局獲得 16 層充能
- 敵人詞綴（普通）
  - 每三次攻擊第三次傷害 ×2.0
- 敵人詞綴（Boss）
  - 每三次攻擊第三次傷害 ×2.0，附加 2 層 Chill
    | 聖遺物詞綴 | 每次攻擊吸血 1%，可疊加最多 20 個 |
    | 裝備詞綴 | 生命值 <10% 時，復活率 +20%、復活生命 +15% |
    | 賽前變數 | 施放大招後，敵人閃避與護甲 -10% |
    | 裝備詞綴 | 每層 Chill 攻擊力 +5% 或 +12 |
    | 裝備詞綴 | 當敵人HP低於50%我的攻擊力+10%,當TargetEnemy生命低於10%我的攻擊命變成他當前生命值得truedamge |
----
FileRelativePath: blueprints\ailment.blueprint.md
# 異常狀態設計概述
## 語意級
### 異常狀態設計階層
異常狀態系統分為靜態定義與動態實例兩個層次：
#### AilmentTemplate（異常狀態模板）
由設計師預先定義，遊戲啟動時全量載入：
- 基本欄位：
  - ID、名稱、類型（如 Chill、Burn、Poison 等）
  - 視覺表現參數（圖示、顏色、動畫）
- 疊加與層數規則：
  - 是否可疊加
  - 最大/最小疊層限制
- 狀態管理規則：
  - 是否可被清除
  - 持續時間或觸發次數限制
- 行為規則參數：
  - 由 effectModule 決定的行為類型與參數（如每 tick 扣血百分比、減速等級）
#### AilmentInstance（異常狀態實例）
動態生成於戰鬥運行時，儲存在角色/敵人的戰鬥 Context 中：
- 關鍵欄位：
  - ailmentTemplateId：指向模板定義
  - currentStack：當前疊層數
  - source：狀態來源（詞綴、技能、事件等）
  - metadata：額外運行時資料（如剩餘時間、觸發次數）
- 生命週期：
  - 狀態賦予時創建實例
  - 每 Tick 執行 effectModule 定義的行為
  - 清除條件觸發時銷毀實例
### 狀態實例設計
## 架構級
### 狀態處理流程
- 每 Tick 步驟：
  - 觸發狀態效果
  - 清除過期/可移除狀態
  - 聚合所有異常狀態對 stat 的影響
### 為何不採用類別處理器
- 類別處理器缺點：
  - 需遍歷所有處理器，效率低
  - 新增狀態需改核心代碼，維護成本高
## 代碼級
### AilmentTemplate 靜態定義
異常狀態模板以資料驅動方式定義，格式範例（JSON）：
```json
{
  "id": "chill",
  "name": "冰緩",
  "type": "debuff",
  "stackable": true,
  "maxStack": 20,
  "removable": true,
  "effectModule": "slow_effect",
  "params": {
    "slowPercentage": 0.1,
    "perStack": true
  }
}
```
### EffectModule 行為規則
行為規則由 effectModule 決定，每個 Tick 觸發一次：
- effectModule 類型範例：
  - `slow_effect`：每層減速固定百分比
  - `damage_effect`：每層造成持續傷害
  - `attribute_modifier`：每層修改屬性
- 參數傳遞：通過 params 欄位傳遞行為所需參數，無需硬編碼
- 執行流程：
  1. 狀態系統每 Tick 遍歷所有 AilmentInstance
  2. 查詢對應的 effectModule
  3. 調用 effectModule 執行函式，傳入 params 與 currentStack
  4. effectModule 計算並應用效果
### Affix 附加異常狀態
詞綴通過 APPLY_STATUS action 附加異常狀態：
- 行為執行：
  - 監聽器捕獲事件（如 ON_HIT）
  - 執行 action: "APPLY_STATUS"，指定目標 ailmentTemplateId 與疊層數
  - 調用 Status System 的 ApplyStatusEffect
- Affix 運作流程（以冰緩為例）：
  - 事件觸發：攻擊命中敵人時觸發 ON_HIT
  - 詞綴行為：監聽器捕獲事件，執行 APPLY_STATUS action
  - 狀態應用：Status System 創建或更新 AilmentInstance，增加對應疊層
----
FileRelativePath: blueprints\character.blueprint.md
# Character（角色）
## 語意級
### 角色的本質
- 本質：
  - Character 本質上是 Unit 類型（戰鬥時）
- 靜態資料：
  - 由一組靜態資料構成，在 RUN 開始時選擇，之後不可更改
- 擁有內容：
  - 屬性
  - 職業
  - 裝備
  - 遺物
  - 絕招（即上述四種東西的擁有者）
- 聚合方式：
  - 模板 + Context 資料聚合
- 行為邏輯：
  - 角色本身不包含「行為邏輯」，而是透過屬性聚合系統和事件監聽器來運作
- 角色職責：
  - 作為一個資料聚合點和戰鬥作用對象
## 架構級
### 角色模組不負責的部分
- 角色面板：
  - 前端會向後端請求完整的 Run Context
  - 面板會顯示角色所有計算後的屬性、已裝備的裝備、遺物、和終極技能
  - 角色面板本身是前端的功能，但資料來源於後端屬性聚合系統的計算結果
- 金錢管理：
  - 角色跟金錢無關
  - 金幣管理是一個獨立的系統，角色實例只管戰鬥與裝備相關的資料，這樣能實現更清晰的系統解耦
## 代碼級
### 角色與敵人的關係
- 共通性：
  - 都是 Unit
- 角色聚合來源：
  - 角色模板
  - 職業
  - 裝備
  - 遺物
  - 大招
  - 當前狀態
- 敵人資料來源：
  - 敵人模板（原型）
  - 關卡生成參數
- 成長方式：
  - 角色透過獲得裝備、遺物、資源來帶來成長
  - 敵人數值成長由難度係數與模板配置
- 狀態生命週期：
  - 各自的異常狀態在戰鬥中動態生成，戰鬥結束後即被清除
----
FileRelativePath: blueprints\combat.blueprint.md
# Combat（戰鬥系統）
## 系統總覽
## Tick 處理流程
- 採用 Tick 輪作設計
  - 行為轉換階段：
    - 事件處理順序
  - 事件處理階段：
    - 每個行為於同 Tick 轉換為 Event 物件，進入 Queue 排隊
  - 狀態系統處理階段
  - 屬性聚合階段
  - 生物狀態判斷階段
  - 日誌與前端回傳階段：
    - 將 Event 物件塞入事件 Queue
## 戰鬥系統組成子系統
- 事件處理階段
- Tick 系統：
  - 按順序同步處理 Queue 內所有事件
- 角色與屬性聚合系統：
  - 命中判定
- 狀態處理系統：
  - 其他瞬發戰鬥事件
- 攻擊與技能系統：
  - 玩家僅戰前配置
- 戰鬥傷害與防禦應對系統：
  - 前端呈現為可控重播（可繼續、暫停、1x~3x 變速，由 UI 負責）
## 戰鬥事件處理細節
- 附加隨機延遲
  - 瞬發戰鬥事件：
    - 模擬完畢後將日誌傳回前端
## 補充說明
- 事件階段：
  - BeforeDamage
  - HitCheck
  - Critical
  - DamageModify
  - Defense
  - BeforeApply
  - Apply
  - AfterApply
- 支援目標選擇策略：
  - 攻擊第一位
  - 血最少
  - 血最多
  - 其他策略
- 重點行動皆進入日誌隊列供重播
### 狀態系統處理階段
- 處理所有 Buff、Debuff、回血、回魔等狀態
- 狀態變化會影響後續屬性聚合
### 屬性聚合階段
- 重新聚合最終屬性
  - 如 HP、魔力、攻擊速度提升等
- 為所有戰鬥行為（如命中判定、傷害輸出）提供最權威的數值
### 生物狀態判斷階段
- 判斷誰死亡、誰存活
- 血量歸零進入死亡檢查
- 依屬性提供起死回生概率（3%~50%）
  - 復活後恢復 10%~100% 血量
  - 復活後異常狀態全部清除
### 日誌與前端回傳階段
- 寫入日誌（放置遊戲類）
- 返回前端（即時戰鬥類）
## 戰鬥系統組成子系統（詳細）
### Tick 系統
- 控制戰鬥流程的時間節奏
### 角色與屬性聚合系統
- 聚合角色所有屬性
- 在 Tick 結束前提供最終屬性數值
### 狀態處理系統
- 處理 Buff、Debuff、Aura、指示器等持續性 Stat 變化
- 異常狀態機制仍在構思，可能大改
- 各類異常狀態：
  - 聖火、充能、冰緩、毒等有各自疊加與觸發規則
  - 無屬性異常如致盲、破甲、出血、褻瀆等
- 裝備、遺物影響：
  - 部分裝備、遺物可改變異常狀態計算方式或效果
### 攻擊與技能系統
- 處理自動攻擊與技能施放
- 適用於無法人為操控的自動戰鬥（如 TFT）
- 攻擊與技能分類：
  - 僅分「普通攻擊」與「大招」兩種
  - 無元素或物理魔法傷害規則之分
  - 大招釋放後，本 Tick 不能普攻
  - 同 Tick 下優先級：大招 > 普攻
- 普通攻擊：
  - 有 cooldown（單位 tick）
- 大招：
  - 需能量條充滿後釋放
  - 無 cooldown
  - 能量條由屬性決定獲取速度，並有自然回復
- 傷害類型：
  - 一般傷害
  - 真實傷害 True Damage（無視任何減免）
- 異常狀態：
  - 獨立於元素
  - 可被裝備、遺物影響
- 閃避與減免機制：
  - 自訂，簡化公式
### 戰鬥傷害與防禦應對系統
- 處理傷害計算、防禦、應對機制
## 戰鬥事件處理細節（詳細）
- 瞬發戰鬥事件：
  - 例如 Damage Event
  - 由傷害解析管道系統處理成最終值
  - 分為多個階段
    - 每階段有對應監聽效果進行處理
## 補充說明（詳細）
- 同 Tick 下，若同時發生致死攻擊與滿血恢復事件：
  - 必須確保處理結果一致，不可隨機
- 所有瞬發戰鬥事件需以事件隊列、連鎖、管道等方式確保發生順序
- 所有子系統合併運作，才構成完整戰鬥系統
----
FileRelativePath: blueprints\creature.blueprint.md
# Entity／Unit／Minion（實體／單位／召喚物）
## 語意級
### 實體的本質
- Entity 擁有各自的戰鬥上下文，但本質上非常抽象
- 作用對象：
  - 可以被狀態、詞綴和戰鬥事件作用
- 玩家與敵人：
  - 都應被視為同一個 Unit 類型，是 Entity 的具體實作
- 召喚物、圖騰：
  - 屬於 Minion，功能比 Unit 少很多
  - Unit 全死亡，但還留著 Minion 依然算輸
## 架構級
### 敵人數據與模板
- 敵人數據來源：
  - 敵人模板（原型）
  - 關卡生成參數
- 模板特性：
  - 靜態，所有 affixes 在模板階段即決定，無需 roll 或權重計算
----
FileRelativePath: blueprints\difficulty.blueprint.md
# Difficulty（難度）
## 語意級
### 難度的影響
- Difficulty 為動態變化的數值（或參數組），用於調整數值生成系統的輸出
- 難度係數決定：
  - 玩家可獲得的裝備
  - 遺物
  - 敵人
  - 關卡
  - 獎勵強度
## 架構級
### 難度的實現
- 本質為一組公式，通常以靜態幫助方法實現
## 難度係數倍率設計（已評估，建議導入）
### 設計原則
- 所有效果（Effect）在生成時，皆會根據「難度係數倍率」調整其數值：
  - 物品
  - 裝備
  - 遺物
  - Ultimate
- 計算公式：
  - 最終數值 = 基底值 × 難度係數 × 詞綴倍率
  - 例：基底 100，難度係數 30，詞綴倍率 0.9，則最終為 100 × 30 × 0.9 = 2700
- 這讓同一模板、同一效果在不同進度下產生不同強度，提升遊戲彈性與平衡
### 業界範例
- Diablo、POE、Hades 等遊戲皆採用類似設計，讓裝備、詞綴、技能等數值隨進度自動調整
### 優缺點
- 優點：
  - 提升遊戲壽命
  - 平衡性
  - 模板可重用性
- 注意事項：
  - 需控制極端值
  - 明確規範倍率計算順序
----
FileRelativePath: blueprints\endless.blueprint.md
# Endless Mode（無盡模式）
## 語意級
### 無盡模式的特點
- 難度曲線：
  - 常規模式採用預定義線性或多項式難度曲線
  - 無盡模式切換為動態、指數級難度曲線，確保敵人成長速度快於玩家累積成長
- 數值顯示：
  - 為避免數值溢出（TypeScript Number 精度有限），使用套件處理大數值顯示（如 977,653K 格式）
- 難度控制：
  - 難度由難度係數模組動態控制
- 特殊 Affixes：
  - 敵人會加入僅此階段出現的特殊 Affixes，裝備亦同
- Boss 節點：
  - 所有節點一律生成為 Boss
- 怪物分布：
  - 不再區分章節才能出現的怪物
- 重生代幣：
  - 剩餘重生代幣（戰敗消耗）會在無盡模式開始前從倉庫移除
----
FileRelativePath: blueprints\generator-weight.blueprint.md
# Generator Weight（生成動態修飾）
## 語意級
### 機制概述
- 動態權重修飾符
- 權重修飾規則：
  - 在 Run 的 Context 中新增一個字段，包含所有當前生效的權重修飾規則的 JSON 陣列
- 權重修飾來源：
  - 系統初始化刻意引導玩家流派
  - 獎勵事件變化
### 權重調整流程
- 適用範圍：
  - 本機制不再適用於 affix，僅適用於其他生成系統（如事件、物品基底 pool）
- 權重調整步驟：
  - 在其他生成邏輯中，將所有基礎 weight 乘以或加上 Context 中對應的修飾值
  - 最後，根據調整後的權重進行抽取選擇
## 架構級
### 設計目的
- 每次 Run 開始時隨機的主題迫使玩家嘗試不同的 Build 策略
- 改變未來內容的生成傾向
----
FileRelativePath: blueprints\inventory.blueprint.md
# Inventory（倉庫）
## 語意級
### 基本功能
- 存入、取出物品（支援批量操作）
- 整理功能：
  - 裝備與遺物分別有 999 個上限
- 過濾與排序（可選）：
  - 類別、稀有度等，建議僅用簡單 SelectBox 實現
### 不建議功能
- 搜尋物品：
  - 不希望玩家需要打字搜尋，遊戲若需搜尋代表設計不夠輕量
## 架構級
### 不負責的內容
- 金幣管理（由其他系統負責）
- 已穿戴裝備（角色管理負責）
- 出售（交易功能負責）
- 交易原子性：
  - 由外部 Transaction 系統處理（本專案不負責實作細節，另在 DynamoDB 專案中實作）
----
FileRelativePath: blueprints\item.blueprint.md
# Item（物品）
## 語意級（設計師閱讀）
### 系統概述
物品系統分類繁多，主題可拆分多套（暫定八套以上）。
物品包含：
- 掉落池：物品可用池。
- 原型（Template）：靜態定義。
- 實例（Instance）：運行時實例。
- 生成流程：直接使用模板中的 affixes 清單。
### 詞綴與物品的關係
- 詞池已固定（詞綴綴定在模板中）。
- 物品模板由 affixes 清單預先綁定。
- 實例化時直接使用模板中的清單，無需 roll 或動態選擇。
### 數值調整與難度係數
- 物品、裝備、遺物的 affix 數值會根據「難度係數倍率」進行調整。
- 物品實例化時，會根據當前關卡或遊戲進度帶入難度係數，計算最終 affix 數值。
- 這讓同一物品模板在不同進度下有不同強度，提升遊戲平衡與多樣性。
## 架構級
### 物品模板（Item Template）
靜態定義包括：
- 名稱、類型、稀有度、裝備窗位。
- 可否堆疊、綁定詞綴陣列、獨特效果。
- 設定檔（JSON）定義所有靜態屬性與詞綴清單。
### 物品實例（Item Instance）
真正存在倉庫/裝備身上的物品：
- itemTemplateId：指向物品模板。
- affixes：由模板預定義的詞綴實例陣列。
- 序列化存入存檔，返序列化還原。
### 物品生成系統
流程層次：
1. 實例化系統：解析設定，讀取模板。
2. 詞綴上載系統：直接從模板中的詞綴。
3. 生成流程：
   - 藍圖載入與實例創建。
   - 根據物品等級、類型從模板池選擇物品基底。
   - 讀取該基底的詞綴。
   - 處理特殊行為模組（詞綴影響戰鬥事件）。
### 遺物與裝備
- 底層都被視為物品。
- 裝備：有穿戴限制，每個 Slot 限一種。
- 遺物：設計偏向疊屬性或疊機制（類似 Risk of Rain 2）。
- 各自能改變玩法或補足屬性。
## 代碼級
### 物品行為與屬性聚合
戰鬥或裝備時：
- 監聽器觸發特殊效果。
- 屬性聚合系統提取 AffixInstance，解析為 StatModifier。
- 轉為戰鬥/面板數值。
### 資料快取與同步
若用 Redis：
- 避免頻繁查詢慢速資料庫。
- 玩家完整角色數據包存於快取。
### 詞綴實例的生命週期
- 物品基底擁有預定義詞綴組合。
- 實例化時直接使用該組合。
- 詞綴實例化為 AffixInstance。
- 戰鬥中作為 Modifier 來源。
- 戰鬥後保留在物品中。
----
FileRelativePath: blueprints\level.blueprint.md
# Level（關卡）
## 語意級
### 關卡生成與流程
每章節（Chapter）的關卡結構與難度分佈：
#### 關卡分佈規則
- 每章節包含 10 關
- 第 5 關（菁英戰）：固定為 ELITE ENEMY
- 第 10 關（首領戰）：固定為 BOSS ENEMY
- 其餘關卡（1-4、6-9 關）：
  - 12% 機率生成事件節點（EVENT）
  - 88% 機率生成普通戰鬥節點（NORMAL ENEMY）
#### 關卡類型
- **normal**（普通戰）：普通敵人
- **elite**（菁英戰）：難度提升的精英敵人
- **boss**（首領戰）：章節 BOSS 級敵人
- **event**（事件）：非戰鬥節點，提供選擇事件
## 架構級
### 關卡生成系統架構
系統分為兩個階段：模板配置與實例生成。
#### 第一階段：章節開始時生成模板配置
流程生成器在章節開始時生成 10 個關卡模板（LevelTemplate）：
- 根據分佈規則配置每關的類型（NORMAL / ELITE / BOSS / EVENT）
- 第 5 關必定為 ELITE_TEMPLATE
- 第 10 關必定為 BOSS_TEMPLATE
- 其餘關卡根據機率分佈（12% EVENT，88% NORMAL）生成對應模板
- 整個模板配置完成後鎖定，供本章節使用
#### 第二階段：玩家進入關卡時生成實例
當玩家點開關卡時，根據模板生成對應實例（LevelInstance）：
- 讀取該關的 LevelTemplate
- 根據模板類型決定生成邏輯：
  - **EnemyLevelInstance**：戰鬥節點
    - 從敵人池選擇並生成敵人實例
    - 應用難度係數調整敵人屬性與詞綴
  - **EventLevelInstance**：事件節點
    - 從事件池選擇事件原型
    - 根據玩家狀態調整事件權重
    - 生成事件實例供玩家互動
- 實例包含完整的運行時資料，可被持久化或即時計算
### 戰鬥節點（Combat Node）
- 敵人篩選：
  - 依條件從敵人原型篩選敵人
- 難度參數：
  - 可附加難度參數（如技能、詞綴隨難度變化，而非僅數值提升）
- 數據預覽：
  - 戰鬥前可預覽敵人數據，戰鬥中亦可能有變化
### 敵人生成
- 敵人以模板（原型）定義
- 模板屬性：
  - ID
  - 出現章節範圍
  - Stat
  - Affixes
- 角色類型：
  - 可否作為 Combat/Boss/Elite 對手等
  - 一個敵人模板可以同時擔任 normal/elite/boss 角色，根據生成參數決定具體配置（如技能變化）
- Affixes 配置：
  - 擔任菁英、首領、普通戰鬥時 Affixes 的配置完全靜態，無需 roll 或權重計算，規則寫在模板中
### 事件生成
- 事件節點生成後，依不同權重選擇原型
- 權重調整：
  - 事件會根據玩家當前狀態調整權重（如金錢過多則給金錢消耗事件）
- 事件原型屬性：
  - id
  - 出現章節
  - 生成觸發條件
  - 類型（道德選擇、風險獎勵等）
  - 選項與文本
## 代碼級
### 章節生成器（ChapterGenerator）
負責在章節開始時生成 10 個關卡模板：
```
1. 初始化配置陣列（10 個位置）
2. 設定第 5 位為 ELITE_TEMPLATE
3. 設定第 10 位為 BOSS_TEMPLATE
4. 對於其餘位置（1-4, 6-9）：
   - 生成 0-100 的隨機數
   - 若 ≤ 12，設置為 EVENT_TEMPLATE
   - 否則設置為 NORMAL_TEMPLATE
5. 返回完成的模板陣列，由 Run Context 儲存
```
### 關卡實例生成器（LevelInstanceGenerator）
當玩家進入關卡時，根據 LevelTemplate 生成對應 Instance：
- **戰鬥類型生成邏輯**：
  1. 檢索 LevelTemplate 中的敵人配置
  2. 從敵人池根據難度篩選敵人原型
  3. 創建 EnemyInstance，應用難度係數倍率至屬性與詞綴
  4. 返回完整的 EnemyLevelInstance
- **事件類型生成邏輯**：
  1. 檢索 LevelTemplate 中的事件配置
  2. 從事件池選擇事件原型
  3. 根據玩家 Run Context（金幣、裝備狀態等）調整事件權重
  4. 選擇並生成 EventLevelInstance
  5. 返回事件及其選項供前端展示
### 事件（Event）
- 結構：
  - 事件為資料模板（Blueprint）+ 即時邏輯執行器
- 原型表：
  - 事件原型表定義文本、選項、每選項對應的 ResultAction 陣列
- 特性：
  - 事件不具 HP、不可被攻擊或賦予狀態，僅為流程控制節點
  - 僅存在於玩家選擇 Event 節點到做出決策的期間
- 選項結果：
  - 選項結果（ResultAction）為核心系統橋樑，定義對 Run Context 的修改
### 範例
- 花費所有金幣，獲得神龍之心
- 嘗試與魔王鏡像對戰一次
- 下場戰鬥獲得 30% 生命加成
### 設計原則
- 請遵循「代碼無狀態、功能解耦」原則，事件僅為流程控制節點，非持久遊戲物件
----
FileRelativePath: blueprints\post-combat.blueprint.md
# Post-Combat（戰後流程）
## 語意級
### 戰敗流程
- 無重生代幣：
  - 進入結算並結束本次 RUN
- 有重生代幣：
  - 消耗一個，返回頁面
  - 提醒商店已更新，且有一項 0 元物品協助繼續戰鬥
### 戰勝流程
- 生成兩個獎勵組合包，請從中二選一
- 每個組合包裡面都會生成兩個 reward item（內容持續設計中）
----
FileRelativePath: blueprints\pre-combat.blueprint.md
# Pre-Combat（戰前流程）
## 語意級
### 流程概述
- 戰鬥前流程，逐步觸發
- 主要包含：
  - 投注系統（戰鬥結果預測）
  - 賽前變數生成（如 TFT 增幅裝置、POE Map 詞綴）
### 下注系統
- 玩家可針對戰鬥結果下注：
  - 例：勝利且剩餘血量區間、造成傷害總額區間
- 賽前投注（血量區間下注）：
  - 玩家下注勝利時剩餘血量區間：
    - 1-10%
    - 11-30%
    - 31-60%
    - 61-100%
  - 猜中獲得相應金幣，猜錯僅得基礎獎勵，沒收投注金
  - 投注金通常為玩家總資產百分比
  - 戰鬥後事件處理派發彩金或沒收獎金
### 賽前變數系統
- 核心：
  - 動態生成規則，效果以狀態實例或屬性修飾符形式注入
- 注入階段：
  - 進入戰鬥前有 1~n 個賽前變數注入階段
- 效果：
  - 通常影響雙方（如開局 16 層 Chill、復活率提升 20%、大招充能效率 ×30%）
- reroll：
  - 玩家可花錢 reroll 賽前變數（但成本高）
----
FileRelativePath: blueprints\profession.blueprint.md
# Profession（職業/專精）
## 語意級
### 職業的影響
- 影響範圍：
  - 影響各領域 Pool 內容
- 起始設定：
  - 起始屬性或配置略有不同
- 選擇時機：
  - 每 RUN 開始時選擇，過程中不可更改
----
FileRelativePath: blueprints\run.blueprint.md
# Run（遊戲流程）
## 語意級
### 核心職責
- Run 負責處理最核心的持久化上下文
- 管理從一開始選角色到戰敗結束整個遊戲後流程
- 是最核心的狀態與流程處理者
## 架構級
### 上下文特性
- Run 的上下文：
  - 不是一個存在於前端的臨時狀態
  - 不是一個依賴伺服器記憶體的活躍物件
  - 是一組存在儲存系統內的資料快照
----
FileRelativePath: blueprints\shop.blueprint.md
# Shop（商店）
## 語意級
### 主要功能
- 購買：
  - 玩家可從商店購買物品
  - 觸發金幣扣除、物品加入倉庫等系統
- 出售：
  - 玩家可將物品賣給商店
  - 出售後獲得金幣，物品從倉庫移除
- 商店刷新：
  - 刷新可能需消耗資源或金幣
  - 刷新時，後端立即生成新物品列表並鎖定，視覺動畫（Roulette）只是前端效果
## 架構級
### 子系統：商店交易系統（Trade System）
- 維護當前物品列表與狀態（已購買、已售出、可刷新等）
- 定價系統：
  - 隨難度提升，價格根據係數增加
  - 支援特價活動，部分物品可臨時降價
- 交易協調：
  - 買賣行為涉及：商店生成物品、倉庫存取、金幣更新
  - 交易系統作為防腐層（ACL），保護核心邏輯不受外部變動影響
  - 買賣規則變更時僅需修改交易系統
- 交易流程：
  - 玩家發起買賣請求
  - 交易系統協調金幣、倉庫、商店三方操作
  - 完成交易後回饋結果給玩家
- 交易原子性：
  - 由外部 Transaction 系統處理（本專案不負責實作細節，另在 DynamoDB 專案中實作）
## 前端視覺上
- 商店的刷新本身要像是 Roulette 旋轉調出的結果，視覺效果吸引人
- 實際上，後端在動畫開始前就已經生成並鎖定物品列表，動畫只是視覺效果，不會改變後端結果
## 多設備同步
- 商店狀態為唯一權威且版本一致
- 多設備登入時，當舊的購買請求到達時，會被拒絕並回傳最新狀態給客戶端
----
FileRelativePath: blueprints\stat.blueprint.md
# Stat（屬性）
## 語意級
### 屬性分類
- maxHp / currentHp。
- maxEnergy / currentEnergy。
- energyRegen / energyGainOnAttack。
- attackDamage / attackCooldown。
- armor / evasion / accuracy。
- criticalChance / criticalMultiplier。
- resurrectionChance / resurrectionHpPercent。
## 架構級
### 屬性聚合與運算
- 聚合來源：
  - 修飾類型（如 +10 點、增加 50%、造成 30% 更多攻擊力）。
  - Added、Multi、More 運算後獲得最終結果。
- 屬性有生命週期，分 Persistent Stats 與 Battle Stats。
- 所有裝備、遺物、大招的 Affix 效果，經解析為 StatModifier 後，由屬性聚合系統轉化為可用數值。
- 異常狀態系統可動態修改屬性，影響戰鬥表現。
- 提供戰鬥行為（攻擊、防禦）所需權威數值。
### 難度係數與 StatModifier
- StatModifier 來源（如 affix、ultimate）在聚合前，已經根據「難度係數倍率」調整過數值。
- 聚合系統僅處理已經計算好的最終值，確保效能與一致性。
## 代碼級
### 設計原則
- StatModifier 來源多元，解析流程應統一。
- 所有來源皆經由轉換器轉為 StatModifier，聚合系統只處理 StatModifier。
- 解析規則資料化，方便擴展與測試。
----
FileRelativePath: blueprints\ultimate.blueprint.md
﻿skillTemplateId: string, // 只能用於該技能
# Ultimate（終極技能）
## 語意級（設計師閱讀）
### 數值調整與難度係數
- Ultimate Effect 數值會根據「難度係數倍率」進行調整。
- 生成 Ultimate 時，會帶入當前關卡或遊戲進度的難度係數。
- 計算公式與 affix 相同，確保技能強度隨進度動態調整。
### 來源與觸發
- Ultimate Gem 源自物品欄位，本身是物品，附帶提供一個技能。
- 戰鬥中玩家能量充滿自動釋放終極技能。
- 釋放後能量重置為零。
### 附魔系統
- Ultimate Gem 本身沒有預設詞綴，需透過附魔石進行附魔。
- 附魔石：特殊道具，消耗制（一次性使用）。
- 附魔來源：獎勵系統（Post-Combat Reward）與商店（Shop）。
- 可用性限制：只有裝備時對應技能，商店和獎勵才會出現該技能的附魔石。
- 多附魔支持：一個技能可附魔多種不同詞綴（相同詞綴只能附魔一次）。
### 池設計
- 來源：固定 ultimate pool（按職業分類與通用 pool）。
- 需求：每 pool 有需求閾值。
- 詞綴池：每個技能有對應的可用詞綴列表。
---
## 架構級（架構師閱讀）
### 技能定義
- Ultimate Gem Template 包含：
  - 技能 ID（如破甲劍、冰刃等）。
  - 基礎效能（傷害、命中率、冷卻等）。
  - 可用詞綴池（該技能能附魔的詞綴清單）。
### 附魔機制
- EnchantStone 結構：
  - affixId：詞綴 ID。
  - skillId：對應的技能。
  - 消耗後從背包移除。
- 附魔流程：
  1. 玩家持有技能對應的附魔石。
  2. 進入裝備/附魔界面，選擇要附魔的技能。
  3. 選擇該技能的未附魔詞綴。
  4. 確認後消耗附魔石，詞綴永久附加。
  5. 詞綴在戰鬥中自動生效。
---
## 代碼級（工程師閱讀）
### 數據結構（暫定）
- 技能實例 SkillInstance：
  - skillTemplateId: string
  - attachedAffixes: AffixInstance[] // 已附魔的詞綴
- 附魔石道具 EnchantStone：
  - affixTemplateId: string
  - skillTemplateId: string // 只能用於該技能
### 附魔應用流程
- 驗證玩家持有附魔石且技能已裝備。
- 驗證該詞綴未被附魔過（無重複）。
- 創建 AffixInstance 並加入 skillInstance.attachedAffixes。
- 消耗（刪除）附魔石道具。
- 持久化到存檔。
### 戰鬥前準備
- 載入已裝備技能的所有 AffixInstance。
- 註冊為事件監聽器與修飾符來源。
- 技能根據附魔詞綴改變行為。
---
## 技能設計範例
1. 消耗能量 100，對血量最低的敵人造成攻擊 240% 傷害，接下來三次命中的攻擊 +5 能量。
2. 消耗能量 100，對敵人施加 150 層中毒，並附加等值的其他異常（冰緩、流血）層數。
3. 消耗能量 100，增加 3000 Armor、3000 Evasion，持續 3000 Ticks。
----
FileRelativePath: instructions\代碼相關.instructions.md
---
applyTo: '/*.ts, /*.tsx, /*.js, /*.jsx'
---
Provide project context and coding guidelines that AI should follow when generating code, answering questions, or reviewing changes.
### 關於代碼
- 乾淨代碼
- 低耦合
- 高內聚
- 可維護性強
- 易讀性高
- 在寫方法與類別的時候要預先想好，這東西是要被單元測試的(但你不用先寫測試)。
- 遵循SOLID原則(尤其是單一職責原則最重要)
- 善用設計模式
- 命名有意義
- KISS,YAGNI,DRY 原則很注重
- 避免魔法數字和魔法字串
- 代碼就是最好的文檔
- 物件關係不應形成循環依賴，依賴應該是單向的
- 如果你要寫 markdown 請以中文為主。
- 你要扮演資深遊戲架構師，重視架構與品質與業界最佳實踐來導入我的方法。
- 一個檔案裡面應該只會包含一個類別或是一個主要功能的程式碼。(Type,Interface 也是如此) 當我搜尋檔案名可以很有效率的找到我想要的東西。
- 當你 Create,Update,Delete 也要關注是否有連動的檔案或spec.md
### 如果這是 OOP
- 建構子不要有過多參數，若有就要用設計模式簡化。
- 禁止使用全局單例
  - 原因: 測試困難(狀態共享)、隱藏依賴、生命週期失控、難以支援多實例場景、跨語言移植困難
- 每個目錄最多 10 個檔案，超過應重構或分類
### 關於註解
- When you refactor or modify code, be sure to update related comments to maintain consistency
- Comments have two purposes
- Help understand complex logic
- Provide a brief one-line description of a function or class's purpose, allowing for quick browsing without diving into the code
- Methods use /_* single-line description *_/
- Class,Type,Interface use // single-line description
- Methods or function logic comments use // single-line description
- I don't need any @param, @returns type comments, as these are redundant
- I found that my colleague's computer does not support Chinese comments, so please
- ZH_TW comments throughout.
### Typescript 檔案與資料夾與物件命名規範
File names:
Almost time, FileName = InternalName
React Components: PascalCase (e.g., UserProfile.tsx)
Class, Abstract Class: PascalCase (e.g., UserProfile.ts)
Utility, Helper, Common: PascalCase (e.g., DataFetch.ts)
Interface, Type, Enum: PascalCase (e.g., IUserProfile,CharacterInformation.ts)
InternalNaming:
Class: PascalCase (e.g., UserProfile)
Class's Interface: I + PascalCase (e.g., IUserProfile)
Data Interface or Type Alias: PascalCase (e.g., UserID)
Enum: PascalCase (e.g., UserRole)
Constants: UPPER_SNAKE_CASE (e.g., MAX_RETRY_COUNT)
Utility, Helper, Common Functions: camelCase (e.g., fetchData)
### 本專案限定內容
- 我們做邏輯(非UI)的內容一律以未來邏輯內容能被 CSharp Python Go 等語言無痛轉移為優先考量
- 再遷移時候不會煩惱依賴某套件、或者耦合某個框架
- 我們使用了模組化架構來做專案結構
- 專案理論上可以被拆成前端與後端與獨立微服務之間不該有耦合，(除非共享契約與邏輯)
- 我們使用了 TS 套件包括:
- 純 TS 套件
  - mitt
  - chance
  - seedrandom
  - nanoid
- 與瀏覽器或 React 互動的 TS 套件
  - heroui/react
  - tailwindcss
  - localforage
  - zustand
#### 模組內的開發守則
- 因為我安裝了 eslint-plugin-boundaries
- 我要讓內部遵循 單向依賴規則：箭頭永遠指向內層。
- 我將模組分成多層結構。同時若模組規模過大，我會在模組內再細分 sub-modules。
- domain/app/adapter/infra
  - domain 核心概念幾乎全部分佈在此
    - 聚合根、實體、值物件、領域服務、領域事件
    - domain 層是核心價值所在，必須保持其純粹性，不被任何外部技術細節污染。
    - 明確要求所有值物件都必須是不可變的
  - app 定義執行流程，協調實體層
    - 應用程式服務、儲存庫介面、服務介面
  - 這層將外部的伺服器技術，與內部的邏輯連接起來。
    - 儲存庫實作、服務實作、呈現器
  - infra這層包含所有技術骨架。
    - 網路框架、配置依賴注入、日誌系統、監控系統
  - 當您有 A,B 兩個不同限界上下文需要合作，防腐層（ACL）通常是必需的。
    - 避免污染核心模型、隔離外部系統的變動、強制單向依賴
    - 下游上下文應該建立防腐層來保護自己免受上游變化的影響。
  - 內層絕不能直接引用外層的實作，若需要外層的能力必須依賴外層定義的介面
- 介面是非常重要的，這樣我們才能解耦與替換實作與測試
- 每個 sub-module 或 module 都應該有一個 index.ts 作為進入點，並且只暴露必要的介面與類別
- 其餘地方不會有任何 index.ts
----
FileRelativePath: instructions\技術概觀.instructions.md
# 技術架構與實現細節 - 2025/12/14
## 簡單來說
- 這是一個不斷修改 Context 狀態的邏輯處理器。輸入舊 Context ，應用業務規則，輸出新 Context 。 Context 驅動的設計。
- 代碼是無狀態的，代表著不同 Server Instance 間可以無痛切換，不會有使用者必須綁定在某一台 Server Instance 上的問題
- 代碼是可水平擴展的，代表著可以輕易增加更多 Server Instance 來應付高流量
- 這專案功能繁多，但不該有狀態保留在服務端的情況，同時代表服務不該存東西在本地端記憶體或檔案系統
- 要注意玩家可能會多裝置或多瀏覽器登入同一帳號(我們只允許一個紀錄事實)，因此所有狀態都必須存放在後端資料庫中，保證唯一真相
## 系統架構分層
### 前端分層
- UI 層：負責純顯示與用戶互動界面，例如按鈕、畫面渲染、動畫效果。不涉及業務邏輯。
- 邏輯層：處理前端業務規則與狀態管理，例如玩家操作驗證、遊戲狀態計算、事件處理。與UI層分離，便於重用。
- Fetch API 層：統一處理數據請求與回應，無論開發階段（本地模擬）或上線階段（真API調用）。封裝網路邏輯，邏輯層透過此層獲取數據。
### 後端分層
- API 層：處理外部請求驗證、路由與中介邏輯，例如用戶登入、請求解析、錯誤處理。作為入口，呼叫遊戲核心層。
- 遊戲核心層：專注處理遊戲邏輯與計算，不關心數據來源（API或直接調用）或儲存方式（Memory或DB）。接收 Context ，執行RUN、戰鬥、商店等操作，返回結果。
## 核心系統盤點
### 後端遊戲機制核心(你現在再處理的東西):
#### 辭典、最基礎的概念群
- 職業
- 屬性
- 異常狀態
- 絕招
- 詞綴
- 物品
  - 裝備
  - 遺物
- 關卡
  - 戰鬥關卡
  - 事件關卡
- 實體
  - 模板敵人
  - 角色
  - 召喚物
  - 戰鬥單位
- 難度
### 內容生成與數據管理系統
- 生成系統
  - 物品生成
  - 詞綴生成
  - 敵人生成
  - 關卡生成
    - 關卡節點生成
    - 敵人配置生成
    - 事件配置生成
- 原型轉實例系統
  - 物品原型轉物品實例
  - 詞綴原型轉詞綴實例
  - 敵人原型轉敵人實例
- 池系統
  - 物品池
  - 敵人池
  - 事件池
- 屬性聚合系統
- 金幣系統
- 戰鬥運算系統
### 高階功能模組
- 戰鬥系統
- RUN 系統
- 商店系統
- 戰鬥前後事務系統
  - 下注遊戲
  - 賽前變數系統
  - 賽後獎勵與生成系統
- 賭博系統
- 倉庫系統
- 角色管理系統
- 商店交易系統
### 前端遊戲核心:
- 角色與裝備面板
- 戰鬥重播系統
- 商店與賭博介面
- 倉庫介面
- RUN 進程介面
- 戰鬥前下注與賽前變數介面
- 戰鬥後獎勵選擇介面
### 後端業務核心:
- 使用者系統(註冊、登入、權限)
- 儲存系統(RUN 狀態、使用者資料)
- 成就系統
- 統計系統
## 儲存系統設計
- 將整個 Run 的 Context 拆分成多個子 JSON 欄位（如角色屬性 JSON、倉庫 JSON、商店 JSON、路線分支 JSON 等），然後將這些欄位存入 NoSQL 資料庫（遊戲核心 NoSQL）。每個 Run 對應一筆記錄，多欄位允許精準更新與查詢。
  - 優點: 小操作（如商店購買）只需讀取/更新相關欄位（如倉庫 JSON），減少 IO 負擔，提升效能。
  - 優點: 支援索引查詢（如金幣欄位），易於找出當前金幣超過三十萬的 RUN，適合統計與分析。
  - 缺點: 欄位間一致性需額外處理（如交易確保多欄位同步），設計複雜度增加。
  - 缺點: 若欄位過多，記錄結構膨脹，仍可能影響載入速度。
  - 我考慮對於 Context 添加 Version 與樂觀鎖機制，確保多欄位更新的一致性與完整性。
- RDB 用於儲存需要高度一致性、交易性、以及明確關聯性的資料，例如帳號資訊、金錢餘額、成就進度等。(後端業務核心)
- 所有遊戲狀態，包括角色的配置與實例，只會在特定的生命週期內(例如一個請求)存在於伺服器的記憶體中。
- 儲存系統(不管 Redis,Pg,Mongo)扮演了遊戲世界的唯一真相
### 上下文分類(絕不存實體，只存模板與狀態，讓實際代碼去還原成物件)
- 角色資訊
- 倉庫
- 商店狀態
- 戰鬥(這個不存入持久)
- 戰鬥前事務
- 戰鬥後事務
- 關卡進程
- 敵人資訊
----
FileRelativePath: instructions\藍圖集合.instructions.md
---
applyTo: '/*.ts, /*.tsx, /*.js, /*.jsx'
---
## Provide project context and coding guidelines that AI should follow when generating code, answering questions, or reviewing changes.
FileRelativePath: blueprints\affix.blueprint.md
# Affix（詞綴）
## 語意級（設計師閱讀）
### 詞綴的定義
Affix（詞綴）是靜態模板，描述遊戲中發生的效果與參數（如影響屬性、觸發行為、賦予狀態）。
模板不包含運行時邏輯，由生成層與運行時系統（事件系統、屬性聚合系統等）協作實現。
### 數值調整與難度係數
- Affix/Effect 數值會根據「難度係數倍率」進行調整。
- 生成 AffixInstance 時，會帶入當前關卡或遊戲進度的難度係數。
- 計算公式範例：
  - 最終數值 = 基底值 × 難度係數 × 詞綴倍率
- 例：基底 100，難度係數 30，詞綴倍率 0.9，則最終為 100 × 30 × 0.9 = 2700。
- 這種設計可讓同一模板在不同進度下產生不同強度，提升遊戲彈性與平衡。
### 詞綴的職責
詞綴模板（AffixTemplate）責任明確：
- 定義行為與基礎數值，保持純粹。
- 不關心持有者或堆疊規則（由載體決定）。
- 所有詞綴由物品模板或敵人模板預先綁定，無動態選擇、無權重、無 roll。
- 效果直接嵌入物品/敵人模板，啟動時全量附加。
### 誰關心 Affix
- 載體：物品、裝備、遺物、終極寶石（Ultimate Gem）。
- 系統：詞綴生成系統、狀態系統、屬性聚合系統、事件系統。
- 表現：賽前變數效果以狀態實例或屬性修飾符（StatModifier）注入。
### 常見問答
#### Q: 詞綴是什麼？
A: 靜態模板，定義效果與參數（ID、Tags、EffectTemplateId 等）。生成與運行時規則由其他系統處理。
#### Q: 修飾符是什麼？
A: 運行時純數值單元（Modifier / StatModifier），由 AffixInstance 與 EffectTemplate 解析產生，被屬性聚合系統使用（Add/Multi/More 等）。
#### Q: 詞綴實體（AffixInstance）如何生成？
A: 物品模板預定義詞綴列表 → 直接附加所有詞綴到物品實例 → 檢查排他/家族規則確保無矛盾 → 建立 AffixInstance 注入目標。
## 架構級
### 名詞定義統一
- AffixTemplate（詞綴模板）
  - 靜態藍圖，定義觸發條件、行為類型與參數
- AffixInstance（詞綴實體）
  - 物品模板綁定的詞綴實例，含 affixTemplateId、sourceId、metadata、uniqueCounter
- Modifier / StatModifier
  - 由 AffixInstance 與 EffectTemplate 解析的純數值修飾，用於屬性運算
### 詞綴層次與轉換
- Affix 屬戰鬥外靜態資源。
- 戰鬥時，Affix 轉換為 1..n 個 Modifier 並送入聚合系統。
- 轉換器（Converter/Binder）由上層注入，負責轉換；聚合系統維持穩定介面。
### 屬性聚合系統
聚合系統要點：
- 僅依賴 StatModifier，不直接認識 AffixTemplate 或 preCombat。
- 轉換器由上層注入，轉換 AffixInstance 與 EffectTemplate 為 ModifierInstance。
- 聚合系統維持穩定介面，便於擴充來源。
### 詞綴綁定結構
- 詞綴直接綁定在模板中：
  - 物品模板綁定：
    - itemTemplate.affixes = [affixId1, affixId2, ...]（無權重、無選擇）
  - 敵人模板綁定：
    - enemyTemplate.affixes（按難度模式不同可設定不同詞綴陣列）
  - 詞綴定義：
    - ID
    - Tags
    - EffectTemplateId
    - 運算方式（Add / Multi / More）
    - 生效條件
    - Family / Exclusion
## 代碼級
### 詞綴生成流程
1. 物品/敵人模板預定義 affixes 陣列。
2. 實例化時直接讀取該陣列中所有詞綴。
3. 檢查 Family / Exclusion 規則，移除矛盾的詞綴組合。
4. 建立 AffixInstance 陣列並注入目標。
   【無選擇、無權重、完全按模板決定。】
### 測試工具：上帝模式
提供「上帝模式」測試工具，具備功能：
- 自由選擇並附加任意詞綴組合到任何載體。
- 用於邊界測試與驗證。
- 正式環境套用 Family/Exclusion/Context 規則以確保平衡。
### 設計原則
- 隔離依賴：Affix 生成涉及多系統，明確隔離避免隱性耦合。
- 轉換器介面：設計專責資料轉換的介面，不放業務規則。
- 事件驅動：多數條件由 EventSystem（OnAttack、OnUltimate、OnDeath、OnCast）實作。
- 狀態語義：狀態/層數、不可逆與堆疊需明確定義。
## 參考構思範例
- 賽前變數
  - 開局獲得 16 層充能
- 敵人詞綴（普通）
  - 每三次攻擊第三次傷害 ×2.0
- 敵人詞綴（Boss）
  - 每三次攻擊第三次傷害 ×2.0，附加 2 層 Chill
    | 聖遺物詞綴 | 每次攻擊吸血 1%，可疊加最多 20 個 |
    | 裝備詞綴 | 生命值 <10% 時，復活率 +20%、復活生命 +15% |
    | 賽前變數 | 施放大招後，敵人閃避與護甲 -10% |
    | 裝備詞綴 | 每層 Chill 攻擊力 +5% 或 +12 |
    | 裝備詞綴 | 當敵人HP低於50%我的攻擊力+10%,當TargetEnemy生命低於10%我的攻擊命變成他當前生命值得truedamge |
---
FileRelativePath: blueprints\ailment.blueprint.md
# 異常狀態設計概述
## 語意級
### 靜態模板設計
- 基本欄位：
  - 名稱
  - ID
  - 類型
- 疊加與層數：
  - 是否可疊加
  - 最大/最小疊層
- 狀態管理：
  - 是否可被清除
  - 行為規則（效果模組）
- 資料結構：
  - 通用資料結構（如 JSON），供所有遊戲內容引用
  - 遊戲啟動或戰鬥加載時載入，內容靜態不變
  - 每個狀態（如 Chill）需有完整靜態定義
### 狀態實例設計
- 套用目標：
  - entity/生物
- 狀態層數：
  - 當前疊層（currentStack）
- 狀態來源：
  - source
- 儲存位置：
  - 儲存於角色戰鬥 Context
- 實例生成：
  - 狀態賦予時創建對應實例
## 架構級
### 狀態處理流程
- 每 Tick 步驟：
  - 觸發狀態效果
  - 清除過期/可移除狀態
  - 聚合所有異常狀態對 stat 的影響
### 為何不採用類別處理器
- 類別處理器缺點：
  - 需遍歷所有處理器，效率低
  - 新增狀態需改核心代碼，維護成本高
## 代碼級
### Affix 附加狀態設計
- 行為執行：
  - 執行行為（effectModule/action，如 APPLY_STATUS）
  - 明確指定觸發時機與效果
### Affix 運作流程（以冰緩為例）
- 事件觸發：
  - 攻擊事件命中敵人時，事件管理器觸發 ON_HIT
- 詞綴行為執行：
  - 監聽器捕獲事件，執行 action: "APPLY_STATUS"
  - 呼叫 Status System 的 ApplyStatusEffect
---
FileRelativePath: blueprints\character.blueprint.md
# Character（角色）
## 語意級
### 角色的本質
- 本質：
  - Character 本質上是 Unit 類型（戰鬥時）
- 靜態資料：
  - 由一組靜態資料構成，在 RUN 開始時選擇，之後不可更改
- 擁有內容：
  - 屬性
  - 職業
  - 裝備
  - 遺物
  - 絕招（即上述四種東西的擁有者）
- 聚合方式：
  - 模板 + Context 資料聚合
- 行為邏輯：
  - 角色本身不包含「行為邏輯」，而是透過屬性聚合系統和事件監聽器來運作
- 角色職責：
  - 作為一個資料聚合點和戰鬥作用對象
## 架構級
### 角色模組不負責的部分
- 角色面板：
  - 前端會向後端請求完整的 Run Context
  - 面板會顯示角色所有計算後的屬性、已裝備的裝備、遺物、和終極技能
  - 角色面板本身是前端的功能，但資料來源於後端屬性聚合系統的計算結果
- 金錢管理：
  - 角色跟金錢無關
  - 金幣管理是一個獨立的系統，角色實例只管戰鬥與裝備相關的資料，這樣能實現更清晰的系統解耦
## 代碼級
### 角色與敵人的關係
- 共通性：
  - 都是 Unit
- 角色聚合來源：
  - 角色模板
  - 職業
  - 裝備
  - 遺物
  - 大招
  - 當前狀態
- 敵人資料來源：
  - 敵人模板（原型）
  - 關卡生成參數
- 成長方式：
  - 角色透過獲得裝備、遺物、資源來帶來成長
  - 敵人數值成長由難度係數與模板配置
- 狀態生命週期：
  - 各自的異常狀態在戰鬥中動態生成，戰鬥結束後即被清除
---
FileRelativePath: blueprints\class.blueprint.md
# Class（職業）
## 語意級
### 職業的影響
- 影響範圍：
  - 影響各領域 Pool 內容
- 起始設定：
  - 起始屬性或配置略有不同
- 選擇時機：
  - 每 RUN 開始時選擇，過程中不可更改
---
FileRelativePath: blueprints\combat.blueprint.md
# Combat（戰鬥系統）
## 系統總覽
## Tick 處理流程
- 採用 Tick 輪作設計
  - 行為轉換階段：
    - 事件處理順序
  - 事件處理階段：
    - 每個行為於同 Tick 轉換為 Event 物件，進入 Queue 排隊
  - 狀態系統處理階段
  - 屬性聚合階段
  - 生物狀態判斷階段
  - 日誌與前端回傳階段：
    - 將 Event 物件塞入事件 Queue
## 戰鬥系統組成子系統
- 事件處理階段
- Tick 系統：
  - 按順序同步處理 Queue 內所有事件
- 角色與屬性聚合系統：
  - 命中判定
- 狀態處理系統：
  - 其他瞬發戰鬥事件
- 攻擊與技能系統：
  - 玩家僅戰前配置
- 戰鬥傷害與防禦應對系統：
  - 前端呈現為可控重播（可繼續、暫停、1x~3x 變速，由 UI 負責）
## 戰鬥事件處理細節
- 附加隨機延遲
  - 瞬發戰鬥事件：
    - 模擬完畢後將日誌傳回前端
## 補充說明
- 事件階段：
  - BeforeDamage
  - HitCheck
  - Critical
  - DamageModify
  - Defense
  - BeforeApply
  - Apply
  - AfterApply
- 支援目標選擇策略：
  - 攻擊第一位
  - 血最少
  - 血最多
  - 其他策略
- 重點行動皆進入日誌隊列供重播
### 狀態系統處理階段
- 處理所有 Buff、Debuff、回血、回魔等狀態
- 狀態變化會影響後續屬性聚合
### 屬性聚合階段
- 重新聚合最終屬性
  - 如 HP、魔力、攻擊速度提升等
- 為所有戰鬥行為（如命中判定、傷害輸出）提供最權威的數值
### 生物狀態判斷階段
- 判斷誰死亡、誰存活
- 血量歸零進入死亡檢查
- 依屬性提供起死回生概率（3%~50%）
  - 復活後恢復 10%~100% 血量
  - 復活後異常狀態全部清除
### 日誌與前端回傳階段
- 寫入日誌（放置遊戲類）
- 返回前端（即時戰鬥類）
## 戰鬥系統組成子系統（詳細）
### Tick 系統
- 控制戰鬥流程的時間節奏
### 角色與屬性聚合系統
- 聚合角色所有屬性
- 在 Tick 結束前提供最終屬性數值
### 狀態處理系統
- 處理 Buff、Debuff、Aura、指示器等持續性 Stat 變化
- 異常狀態機制仍在構思，可能大改
- 各類異常狀態：
  - 聖火、充能、冰緩、毒等有各自疊加與觸發規則
  - 無屬性異常如致盲、破甲、出血、褻瀆等
- 裝備、遺物影響：
  - 部分裝備、遺物可改變異常狀態計算方式或效果
### 攻擊與技能系統
- 處理自動攻擊與技能施放
- 適用於無法人為操控的自動戰鬥（如 TFT）
- 攻擊與技能分類：
  - 僅分「普通攻擊」與「大招」兩種
  - 無元素或物理魔法傷害規則之分
  - 大招釋放後，本 Tick 不能普攻
  - 同 Tick 下優先級：大招 > 普攻
- 普通攻擊：
  - 有 cooldown（單位 tick）
- 大招：
  - 需能量條充滿後釋放
  - 無 cooldown
  - 能量條由屬性決定獲取速度，並有自然回復
- 傷害類型：
  - 一般傷害
  - 真實傷害 True Damage（無視任何減免）
- 異常狀態：
  - 獨立於元素
  - 可被裝備、遺物影響
- 閃避與減免機制：
  - 自訂，簡化公式
### 戰鬥傷害與防禦應對系統
- 處理傷害計算、防禦、應對機制
## 戰鬥事件處理細節（詳細）
- 瞬發戰鬥事件：
  - 例如 Damage Event
  - 由傷害解析管道系統處理成最終值
  - 分為多個階段
    - 每階段有對應監聽效果進行處理
## 補充說明（詳細）
- 同 Tick 下，若同時發生致死攻擊與滿血恢復事件：
  - 必須確保處理結果一致，不可隨機
- 所有瞬發戰鬥事件需以事件隊列、連鎖、管道等方式確保發生順序
- 所有子系統合併運作，才構成完整戰鬥系統
---
FileRelativePath: blueprints\creature.blueprint.md
# Entity／Unit／Minion（實體／單位／召喚物）
## 語意級
### 實體的本質
- Entity 擁有各自的戰鬥上下文，但本質上非常抽象
- 作用對象：
  - 可以被狀態、詞綴和戰鬥事件作用
- 玩家與敵人：
  - 都應被視為同一個 Unit 類型，是 Entity 的具體實作
- 召喚物、圖騰：
  - 屬於 Minion，功能比 Unit 少很多
  - Unit 全死亡，但還留著 Minion 依然算輸
## 架構級
### 敵人數據與模板
- 敵人數據來源：
  - 敵人模板（原型）
  - 關卡生成參數
- 模板特性：
  - 靜態，所有 affixes 在模板階段即決定，無需 roll 或權重計算
---
FileRelativePath: blueprints\difficulty.blueprint.md
# Difficulty（難度）
## 語意級
### 難度的影響
- Difficulty 為動態變化的數值（或參數組），用於調整數值生成系統的輸出
- 難度係數決定：
  - 玩家可獲得的裝備
  - 遺物
  - 敵人
  - 關卡
  - 獎勵強度
## 架構級
### 難度的實現
- 本質為一組公式，通常以靜態幫助方法實現
## 難度係數倍率設計（已評估，建議導入）
### 設計原則
- 所有效果（Effect）在生成時，皆會根據「難度係數倍率」調整其數值：
  - 物品
  - 裝備
  - 遺物
  - Ultimate
- 計算公式：
  - 最終數值 = 基底值 × 難度係數 × 詞綴倍率
  - 例：基底 100，難度係數 30，詞綴倍率 0.9，則最終為 100 × 30 × 0.9 = 2700
- 這讓同一模板、同一效果在不同進度下產生不同強度，提升遊戲彈性與平衡
### 業界範例
- Diablo、POE、Hades 等遊戲皆採用類似設計，讓裝備、詞綴、技能等數值隨進度自動調整
### 優缺點
- 優點：
  - 提升遊戲壽命
  - 平衡性
  - 模板可重用性
- 注意事項：
  - 需控制極端值
  - 明確規範倍率計算順序
---
FileRelativePath: blueprints\endless.blueprint.md
# Endless Mode（無盡模式）
## 語意級
### 無盡模式的特點
- 難度曲線：
  - 常規模式採用預定義線性或多項式難度曲線
  - 無盡模式切換為動態、指數級難度曲線，確保敵人成長速度快於玩家累積成長
- 數值顯示：
  - 為避免數值溢出（TypeScript Number 精度有限），使用套件處理大數值顯示（如 977,653K 格式）
- 難度控制：
  - 難度由難度係數模組動態控制
- 特殊 Affixes：
  - 敵人會加入僅此階段出現的特殊 Affixes，裝備亦同
- Boss 節點：
  - 所有節點一律生成為 Boss
- 怪物分布：
  - 不再區分章節才能出現的怪物
- 重生代幣：
  - 剩餘重生代幣（戰敗消耗）會在無盡模式開始前從倉庫移除
---
FileRelativePath: blueprints\generator-weight.blueprint.md
# Generator Weight（生成動態修飾）
## 語意級
### 機制概述
- 動態權重修飾符
- 權重修飾規則：
  - 在 Run 的 Context 中新增一個字段，包含所有當前生效的權重修飾規則的 JSON 陣列
- 權重修飾來源：
  - 系統初始化刻意引導玩家流派
  - 獎勵事件變化
### 權重調整流程
- 適用範圍：
  - 本機制不再適用於 affix，僅適用於其他生成系統（如事件、物品基底 pool）
- 權重調整步驟：
  - 在其他生成邏輯中，將所有基礎 weight 乘以或加上 Context 中對應的修飾值
  - 最後，根據調整後的權重進行抽取選擇
## 架構級
### 設計目的
- 每次 Run 開始時隨機的主題迫使玩家嘗試不同的 Build 策略
- 改變未來內容的生成傾向
---
FileRelativePath: blueprints\inventory.blueprint.md
# Inventory（倉庫）
## 語意級
### 基本功能
- 存入、取出物品（支援批量操作）
- 整理功能：
  - 裝備與遺物分別有 999 個上限
- 過濾與排序（可選）：
  - 類別、稀有度等，建議僅用簡單 SelectBox 實現
### 不建議功能
- 搜尋物品：
  - 不希望玩家需要打字搜尋，遊戲若需搜尋代表設計不夠輕量
## 架構級
### 不負責的內容
- 金幣管理（由其他系統負責）
- 已穿戴裝備（角色管理負責）
- 出售（交易功能負責）
- 交易原子性：
  - 由外部 Transaction 系統處理（本專案不負責實作細節，另在 DynamoDB 專案中實作）
---
FileRelativePath: blueprints\item.blueprint.md
# Item（物品）
## 語意級（設計師閱讀）
### 系統概述
物品系統分類繁多，主題可拆分多套（暫定八套以上）。
物品包含：
- 掉落池：物品可用池。
- 原型（Template）：靜態定義。
- 實例（Instance）：運行時實例。
- 生成流程：直接使用模板中的 affixes 清單。
### 詞綴與物品的關係
- 詞池已固定（詞綴綴定在模板中）。
- 物品模板由 affixes 清單預先綁定。
- 實例化時直接使用模板中的清單，無需 roll 或動態選擇。
### 數值調整與難度係數
- 物品、裝備、遺物的 affix 數值會根據「難度係數倍率」進行調整。
- 物品實例化時，會根據當前關卡或遊戲進度帶入難度係數，計算最終 affix 數值。
- 這讓同一物品模板在不同進度下有不同強度，提升遊戲平衡與多樣性。
## 架構級
### 物品模板（Item Template）
靜態定義包括：
- 名稱、類型、稀有度、裝備窗位。
- 可否堆疊、綁定詞綴陣列、獨特效果。
- 設定檔（JSON）定義所有靜態屬性與詞綴清單。
### 物品實例（Item Instance）
真正存在倉庫/裝備身上的物品：
- itemTemplateId：指向物品模板。
- affixes：由模板預定義的詞綴實例陣列。
- 序列化存入存檔，返序列化還原。
### 物品生成系統
流程層次：
1. 實例化系統：解析設定，讀取模板。
2. 詞綴上載系統：直接從模板中的詞綴。
3. 生成流程：
   - 藍圖載入與實例創建。
   - 根據物品等級、類型從模板池選擇物品基底。
   - 讀取該基底的詞綴。
   - 處理特殊行為模組（詞綴影響戰鬥事件）。
### 遺物與裝備
- 底層都被視為物品。
- 裝備：有穿戴限制，每個 Slot 限一種。
- 遺物：設計偏向疊屬性或疊機制（類似 Risk of Rain 2）。
- 各自能改變玩法或補足屬性。
## 代碼級
### 物品行為與屬性聚合
戰鬥或裝備時：
- 監聽器觸發特殊效果。
- 屬性聚合系統提取 AffixInstance，解析為 StatModifier。
- 轉為戰鬥/面板數值。
### 資料快取與同步
若用 Redis：
- 避免頻繁查詢慢速資料庫。
- 玩家完整角色數據包存於快取。
### 詞綴實例的生命週期
- 物品基底擁有預定義詞綴組合。
- 實例化時直接使用該組合。
- 詞綴實例化為 AffixInstance。
- 戰鬥中作為 Modifier 來源。
- 戰鬥後保留在物品中。
---
FileRelativePath: blueprints\level.blueprint.md
# Level（關卡）
## 語意級
### 關卡類型
- normal（普通戰）
- elite（菁英戰，第5關固定）
- boss（首領戰，第10關固定）
- event（事件）
- normal/event 節點依機率分布生成
- 僅有單一路線，不產生分岔圖（非 Slay the Spire 類型）
## 架構級
### 戰鬥節點（Combat Node）
- 敵人篩選：
  - 依條件從敵人原型篩選敵人
- 難度參數：
  - 可附加難度參數（如技能、詞綴隨難度變化，而非僅數值提升）
- 數據預覽：
  - 戰鬥前可預覽敵人數據，戰鬥中亦可能有變化
### 敵人生成
- 敵人以模板（原型）定義
- 模板屬性：
  - ID
  - 出現章節範圍
  - Stat
  - Affixes
- 角色類型：
  - 可否作為 Combat/Boss/Elite 對手等
  - 一個敵人模板可以同時擔任 normal/elite/boss 角色，根據生成參數決定具體配置（如技能變化）
- Affixes 配置：
  - 擔任菁英、首領、普通戰鬥時 Affixes 的配置完全靜態，無需 roll 或權重計算，規則寫在模板中
### 事件生成
- 事件節點生成後，依不同權重選擇原型
- 權重調整：
  - 事件會根據玩家當前狀態調整權重（如金錢過多則給金錢消耗事件）
- 事件原型屬性：
  - id
  - 出現章節
  - 生成觸發條件
  - 類型（道德選擇、風險獎勵等）
  - 選項與文本
## 代碼級
### 事件（Event）
- 結構：
  - 事件為資料模板（Blueprint）+ 即時邏輯執行器
- 原型表：
  - 事件原型表定義文本、選項、每選項對應的 ResultAction 陣列
- 特性：
  - 事件不具 HP、不可被攻擊或賦予狀態，僅為流程控制節點
  - 僅存在於玩家選擇 Event 節點到做出決策的期間
- 選項結果：
  - 選項結果（ResultAction）為核心系統橋樑，定義對 Run Context 的修改
### 範例
- 花費所有金幣，獲得神龍之心
- 嘗試與魔王鏡像對戰一次
- 下場戰鬥獲得 30% 生命加成
### 設計原則
- 請遵循「代碼無狀態、功能解耦」原則，事件僅為流程控制節點，非持久遊戲物件
---
FileRelativePath: blueprints\post-combat.blueprint.md
# Post-Combat（戰後流程）
## 語意級
### 戰敗流程
- 無重生代幣：
  - 進入結算並結束本次 RUN
- 有重生代幣：
  - 消耗一個，返回頁面
  - 提醒商店已更新，且有一項 0 元物品協助繼續戰鬥
### 戰勝流程
- 生成兩個獎勵組合包，請從中二選一
- 每個組合包裡面都會生成兩個 reward item（內容持續設計中）
---
FileRelativePath: blueprints\pre-combat.blueprint.md
# Pre-Combat（戰前流程）
## 語意級
### 流程概述
- 戰鬥前流程，逐步觸發
- 主要包含：
  - 投注系統（戰鬥結果預測）
  - 賽前變數生成（如 TFT 增幅裝置、POE Map 詞綴）
### 下注系統
- 玩家可針對戰鬥結果下注：
  - 例：勝利且剩餘血量區間、造成傷害總額區間
- 賽前投注（血量區間下注）：
  - 玩家下注勝利時剩餘血量區間：
    - 1-10%
    - 11-30%
    - 31-60%
    - 61-100%
  - 猜中獲得相應金幣，猜錯僅得基礎獎勵，沒收投注金
  - 投注金通常為玩家總資產百分比
  - 戰鬥後事件處理派發彩金或沒收獎金
### 賽前變數系統
- 核心：
  - 動態生成規則，效果以狀態實例或屬性修飾符形式注入
- 注入階段：
  - 進入戰鬥前有 1~n 個賽前變數注入階段
- 效果：
  - 通常影響雙方（如開局 16 層 Chill、復活率提升 20%、大招充能效率 ×30%）
- reroll：
  - 玩家可花錢 reroll 賽前變數（但成本高）
---
FileRelativePath: blueprints\run.blueprint.md
# Run（遊戲流程）
## 語意級
### 核心職責
- Run 負責處理最核心的持久化上下文
- 管理從一開始選角色到戰敗結束整個遊戲後流程
- 是最核心的狀態與流程處理者
## 架構級
### 上下文特性
- Run 的上下文：
  - 不是一個存在於前端的臨時狀態
  - 不是一個依賴伺服器記憶體的活躍物件
  - 是一組存在儲存系統內的資料快照
---
FileRelativePath: blueprints\shop.blueprint.md
# Shop（商店）
## 語意級
### 主要功能
- 購買：
  - 玩家可從商店購買物品
  - 觸發金幣扣除、物品加入倉庫等系統
- 出售：
  - 玩家可將物品賣給商店
  - 出售後獲得金幣，物品從倉庫移除
- 商店刷新：
  - 刷新可能需消耗資源或金幣
  - 刷新時，後端立即生成新物品列表並鎖定，視覺動畫（Roulette）只是前端效果
## 架構級
### 子系統：商店交易系統（Trade System）
- 維護當前物品列表與狀態（已購買、已售出、可刷新等）
- 定價系統：
  - 隨難度提升，價格根據係數增加
  - 支援特價活動，部分物品可臨時降價
- 交易協調：
  - 買賣行為涉及：商店生成物品、倉庫存取、金幣更新
  - 交易系統作為防腐層（ACL），保護核心邏輯不受外部變動影響
  - 買賣規則變更時僅需修改交易系統
- 交易流程：
  - 玩家發起買賣請求
  - 交易系統協調金幣、倉庫、商店三方操作
  - 完成交易後回饋結果給玩家
- 交易原子性：
  - 由外部 Transaction 系統處理（本專案不負責實作細節，另在 DynamoDB 專案中實作）
## 前端視覺上
- 商店的刷新本身要像是 Roulette 旋轉調出的結果，視覺效果吸引人
- 實際上，後端在動畫開始前就已經生成並鎖定物品列表，動畫只是視覺效果，不會改變後端結果
## 多設備同步
- 商店狀態為唯一權威且版本一致
- 多設備登入時，當舊的購買請求到達時，會被拒絕並回傳最新狀態給客戶端
---
FileRelativePath: blueprints\stat.blueprint.md
# Stat（屬性）
## 語意級
### 屬性分類
- maxHp / currentHp。
- maxEnergy / currentEnergy。
- energyRegen / energyGainOnAttack。
- attackDamage / attackCooldown。
- armor / evasion / accuracy。
- criticalChance / criticalMultiplier。
- resurrectionChance / resurrectionHpPercent。
## 架構級
### 屬性聚合與運算
- 聚合來源：
  - 修飾類型（如 +10 點、增加 50%、造成 30% 更多攻擊力）。
  - Added、Multi、More 運算後獲得最終結果。
- 屬性有生命週期，分 Persistent Stats 與 Battle Stats。
- 所有裝備、遺物、大招的 Affix 效果，經解析為 StatModifier 後，由屬性聚合系統轉化為可用數值。
- 異常狀態系統可動態修改屬性，影響戰鬥表現。
- 提供戰鬥行為（攻擊、防禦）所需權威數值。
### 難度係數與 StatModifier
- StatModifier 來源（如 affix、ultimate）在聚合前，已經根據「難度係數倍率」調整過數值。
- 聚合系統僅處理已經計算好的最終值，確保效能與一致性。
## 代碼級
### 設計原則
- StatModifier 來源多元，解析流程應統一。
- 所有來源皆經由轉換器轉為 StatModifier，聚合系統只處理 StatModifier。
- 解析規則資料化，方便擴展與測試。
---
FileRelativePath: blueprints\ultimate.blueprint.md
﻿skillTemplateId: string, // 只能用於該技能
# Ultimate（終極技能）
## 語意級（設計師閱讀）
### 數值調整與難度係數
- Ultimate Effect 數值會根據「難度係數倍率」進行調整。
- 生成 Ultimate 時，會帶入當前關卡或遊戲進度的難度係數。
- 計算公式與 affix 相同，確保技能強度隨進度動態調整。
### 來源與觸發
- Ultimate Gem 源自物品欄位，本身是物品，附帶提供一個技能。
- 戰鬥中玩家能量充滿自動釋放終極技能。
- 釋放後能量重置為零。
### 附魔系統
- Ultimate Gem 本身沒有預設詞綴，需透過附魔石進行附魔。
- 附魔石：特殊道具，消耗制（一次性使用）。
- 附魔來源：獎勵系統（Post-Combat Reward）與商店（Shop）。
- 可用性限制：只有裝備時對應技能，商店和獎勵才會出現該技能的附魔石。
- 多附魔支持：一個技能可附魔多種不同詞綴（相同詞綴只能附魔一次）。
### 池設計
- 來源：固定 ultimate pool（按職業分類與通用 pool）。
- 需求：每 pool 有需求閾值。
- 詞綴池：每個技能有對應的可用詞綴列表。
---
## 架構級（架構師閱讀）
### 技能定義
- Ultimate Gem Template 包含：
  - 技能 ID（如破甲劍、冰刃等）。
  - 基礎效能（傷害、命中率、冷卻等）。
  - 可用詞綴池（該技能能附魔的詞綴清單）。
### 附魔機制
- EnchantStone 結構：
  - affixId：詞綴 ID。
  - skillId：對應的技能。
  - 消耗後從背包移除。
- 附魔流程：
  1. 玩家持有技能對應的附魔石。
  2. 進入裝備/附魔界面，選擇要附魔的技能。
  3. 選擇該技能的未附魔詞綴。
  4. 確認後消耗附魔石，詞綴永久附加。
  5. 詞綴在戰鬥中自動生效。
---
## 代碼級（工程師閱讀）
### 數據結構（暫定）
- 技能實例 SkillInstance：
  - skillTemplateId: string
  - attachedAffixes: AffixInstance[] // 已附魔的詞綴
- 附魔石道具 EnchantStone：
  - affixTemplateId: string
  - skillTemplateId: string // 只能用於該技能
### 附魔應用流程
- 驗證玩家持有附魔石且技能已裝備。
- 驗證該詞綴未被附魔過（無重複）。
- 創建 AffixInstance 並加入 skillInstance.attachedAffixes。
- 消耗（刪除）附魔石道具。
- 持久化到存檔。
### 戰鬥前準備
- 載入已裝備技能的所有 AffixInstance。
- 註冊為事件監聽器與修飾符來源。
- 技能根據附魔詞綴改變行為。
---
## 技能設計範例
1. 消耗能量 100，對血量最低的敵人造成攻擊 240% 傷害，接下來三次命中的攻擊 +5 能量。
2. 消耗能量 100，對敵人施加 150 層中毒，並附加等值的其他異常（冰緩、流血）層數。
3. 消耗能量 100，增加 3000 Armor、3000 Evasion，持續 3000 Ticks。
---
## FileRelativePath: instructions\代碼相關.instructions.md
## applyTo: '/_.ts, /_.tsx, /_.js, /_.jsx'
Provide project context and coding guidelines that AI should follow when generating code, answering questions, or reviewing changes.
### 關於代碼
- 乾淨代碼
- 低耦合
- 高內聚
- 可維護性強
- 易讀性高
- 在寫方法與類別的時候要預先想好，這東西是要被單元測試的(但你不用先寫測試)。
- 遵循SOLID原則(尤其是單一職責原則最重要)
- 善用設計模式
- 命名有意義
- KISS,YAGNI,DRY 原則很注重
- 避免魔法數字和魔法字串
- 代碼就是最好的文檔
- 物件關係不應形成循環依賴，依賴應該是單向的
- 如果你要寫 markdown 請以中文為主。
- 你要扮演資深遊戲架構師，重視架構與品質與業界最佳實踐來導入我的方法。
- 一個檔案裡面應該只會包含一個類別或是一個主要功能的程式碼。(Type,Interface 也是如此) 當我搜尋檔案名可以很有效率的找到我想要的東西。
- 當你 Create,Update,Delete 也要關注是否有連動的檔案或spec.md
### 如果這是 OOP
- 建構子不要有過多參數，若有就要用設計模式簡化。
- 禁止使用全局單例
  - 原因: 測試困難(狀態共享)、隱藏依賴、生命週期失控、難以支援多實例場景、跨語言移植困難
- 每個目錄最多 10 個檔案，超過應重構或分類
### 關於註解
- When you refactor or modify code, be sure to update related comments to maintain consistency
- Comments have two purposes
- Help understand complex logic
- Provide a brief one-line description of a function or class's purpose, allowing for quick browsing without diving into the code
- Methods use /_* single-line description *_/
- Class,Type,Interface use // single-line description
- Methods or function logic comments use // single-line description
- I don't need any @param, @returns type comments, as these are redundant
- I found that my colleague's computer does not support Chinese comments, so please
- ZH_TW comments throughout.
### Typescript 檔案與資料夾與物件命名規範
File names:
Almost time, FileName = InternalName
React Components: PascalCase (e.g., UserProfile.tsx)
Class, Abstract Class: PascalCase (e.g., UserProfile.ts)
Utility, Helper, Common: PascalCase (e.g., DataFetch.ts)
Interface, Type, Enum: PascalCase (e.g., IUserProfile,CharacterInformation.ts)
InternalNaming:
Class: PascalCase (e.g., UserProfile)
Class's Interface: I + PascalCase (e.g., IUserProfile)
Data Interface or Type Alias: PascalCase (e.g., UserID)
Enum: PascalCase (e.g., UserRole)
Constants: UPPER_SNAKE_CASE (e.g., MAX_RETRY_COUNT)
Utility, Helper, Common Functions: camelCase (e.g., fetchData)
### 本專案限定內容
- 我們做邏輯(非UI)的內容一律以未來邏輯內容能被 CSharp Python Go 等語言無痛轉移為優先考量
- 再遷移時候不會煩惱依賴某套件、或者耦合某個框架
- 我們使用了模組化架構來做專案結構
- 專案理論上可以被拆成前端與後端與獨立微服務之間不該有耦合，(除非共享契約與邏輯)
- 我們使用了 TS 套件包括:
- 純 TS 套件
  - mitt
  - chance
  - seedrandom
  - nanoid
- 與瀏覽器或 React 互動的 TS 套件
  - heroui/react
  - tailwindcss
  - localforage
  - zustand
#### 模組內的開發守則
- 因為我安裝了 eslint-plugin-boundaries
- 我要讓內部遵循 單向依賴規則：箭頭永遠指向內層。
- 我將模組分成多層結構。同時若模組規模過大，我會在模組內再細分 sub-modules。
- domain/app/adapter/infra
  - domain 核心概念幾乎全部分佈在此
    - 聚合根、實體、值物件、領域服務、領域事件
    - domain 層是核心價值所在，必須保持其純粹性，不被任何外部技術細節污染。
    - 明確要求所有值物件都必須是不可變的
  - app 定義執行流程，協調實體層
    - 應用程式服務、儲存庫介面、服務介面
  - 這層將外部的伺服器技術，與內部的邏輯連接起來。
    - 儲存庫實作、服務實作、呈現器
  - infra這層包含所有技術骨架。
    - 網路框架、配置依賴注入、日誌系統、監控系統
  - 當您有 A,B 兩個不同限界上下文需要合作，防腐層（ACL）通常是必需的。
    - 避免污染核心模型、隔離外部系統的變動、強制單向依賴
    - 下游上下文應該建立防腐層來保護自己免受上游變化的影響。
  - 內層絕不能直接引用外層的實作，若需要外層的能力必須依賴外層定義的介面
- 介面是非常重要的，這樣我們才能解耦與替換實作與測試
- 每個 sub-module 或 module 都應該有一個 index.ts 作為進入點，並且只暴露必要的介面與類別
- 其餘地方不會有任何 index.ts
---
FileRelativePath: instructions\技術概觀.instructions.md
# 技術架構與實現細節 - 2025/12/14
## 簡單來說
- 這是一個不斷修改 Context 狀態的邏輯處理器。輸入舊 Context ，應用業務規則，輸出新 Context 。 Context 驅動的設計。
- 代碼是無狀態的，代表著不同 Server Instance 間可以無痛切換，不會有使用者必須綁定在某一台 Server Instance 上的問題
- 代碼是可水平擴展的，代表著可以輕易增加更多 Server Instance 來應付高流量
- 這專案功能繁多，但不該有狀態保留在服務端的情況，同時代表服務不該存東西在本地端記憶體或檔案系統
- 要注意玩家可能會多裝置或多瀏覽器登入同一帳號(我們只允許一個紀錄事實)，因此所有狀態都必須存放在後端資料庫中，保證唯一真相
## 系統架構分層
### 前端分層
- UI 層：負責純顯示與用戶互動界面，例如按鈕、畫面渲染、動畫效果。不涉及業務邏輯。
- 邏輯層：處理前端業務規則與狀態管理，例如玩家操作驗證、遊戲狀態計算、事件處理。與UI層分離，便於重用。
- Fetch API 層：統一處理數據請求與回應，無論開發階段（本地模擬）或上線階段（真API調用）。封裝網路邏輯，邏輯層透過此層獲取數據。
### 後端分層
- API 層：處理外部請求驗證、路由與中介邏輯，例如用戶登入、請求解析、錯誤處理。作為入口，呼叫遊戲核心層。
- 遊戲核心層：專注處理遊戲邏輯與計算，不關心數據來源（API或直接調用）或儲存方式（Memory或DB）。接收 Context ，執行RUN、戰鬥、商店等操作，返回結果。
## 核心系統盤點
### 後端遊戲機制核心(你現在再處理的東西):
#### 辭典、最基礎的概念群
- 職業
- 屬性
- 物品
  - 裝備
  - 遺物
- 詞綴
- 關卡
- 事件
- 敵人
- 異常狀態
- 難度
- 絕招(技能)
### 內容生成與數據管理系統
- 生成系統
  - 物品生成
  - 詞綴生成
  - 敵人生成
  - 關卡生成
    - 關卡節點生成
    - 敵人配置生成
    - 事件配置生成
- 原型轉實例系統
  - 物品原型轉物品實例
  - 詞綴原型轉詞綴實例
  - 敵人原型轉敵人實例
- 池系統
  - 物品池
  - 敵人池
  - 事件池
- 屬性聚合系統
- 金幣系統
- 戰鬥運算系統
### 高階功能模組
- 戰鬥系統
- RUN 系統
- 商店系統
- 戰鬥前後事務系統
  - 下注遊戲
  - 賽前變數系統
  - 賽後獎勵與生成系統
- 賭博系統
- 倉庫系統
- 角色管理系統
- 商店交易系統
### 前端遊戲核心:
- 角色與裝備面板
- 戰鬥重播系統
- 商店與賭博介面
- 倉庫介面
- RUN 進程介面
- 戰鬥前下注與賽前變數介面
- 戰鬥後獎勵選擇介面
### 後端業務核心:
- 使用者系統(註冊、登入、權限)
- 儲存系統(RUN 狀態、使用者資料)
- 成就系統
- 統計系統
## 儲存系統設計
- 將整個 Run 的 Context 拆分成多個子 JSON 欄位（如角色屬性 JSON、倉庫 JSON、商店 JSON、路線分支 JSON 等），然後將這些欄位存入 NoSQL 資料庫（遊戲核心 NoSQL）。每個 Run 對應一筆記錄，多欄位允許精準更新與查詢。
  - 優點: 小操作（如商店購買）只需讀取/更新相關欄位（如倉庫 JSON），減少 IO 負擔，提升效能。
  - 優點: 支援索引查詢（如金幣欄位），易於找出當前金幣超過三十萬的 RUN，適合統計與分析。
  - 缺點: 欄位間一致性需額外處理（如交易確保多欄位同步），設計複雜度增加。
  - 缺點: 若欄位過多，記錄結構膨脹，仍可能影響載入速度。
  - 我考慮對於 Context 添加 Version 與樂觀鎖機制，確保多欄位更新的一致性與完整性。
- RDB 用於儲存需要高度一致性、交易性、以及明確關聯性的資料，例如帳號資訊、金錢餘額、成就進度等。(後端業務核心)
- 所有遊戲狀態，包括角色的配置與實例，只會在特定的生命週期內(例如一個請求)存在於伺服器的記憶體中。
- 儲存系統(不管 Redis,Pg,Mongo)扮演了遊戲世界的唯一真相
### 上下文分類(絕不存實體，只存模板與狀態，讓實際代碼去還原成物件)
- 角色資訊
- 倉庫
- 商店狀態
- 戰鬥(這個不存入持久)
- 戰鬥前事務
- 戰鬥後事務
- 關卡進程
- 敵人資訊
---
FileRelativePath: instructions\遊戲介紹.instructions.md
# 遊戲機制大綱 - 2025/12/14
## 大致方向
### 故事背景
- 身為一名落魄貴族，你把手頭的錢都拿去買一名決鬥者，你將培養該決鬥者，在競技場挑戰強敵，賺取資源，重振家族榮耀。
### 遊戲核心概念
- 這個遊戲本質上是 RogueLite Run
- 資源下注挑戰隨機戰鬥，目標是存活到越後面越好.
### 鎖定的目標群體
- 輕度玩家、懶得操作的玩家。
- 上班摸魚、通勤無聊時間玩。
- 喜歡每次開局都不一樣的玩家。
- 喜歡改版頻繁的玩家。
### 玩家可以做什麼?
- 玩家操作極簡，符合輕度目標群（懶得操作），甚至懶得查攻略也該能玩。
- 開局: 選角色 + 其他配置
- 戰鬥外: 逛商店、賭博、管理倉庫與裝備、查看狀態
- 戰鬥前: 下注血量區間、觸發賽前變數
- 戰鬥中: 自動進行
- 戰鬥後: 勝利則選獎勵觸發事件（獲得獎勵或挑戰），然後循環回戰鬥外，否則進入戰鬥失敗處理流程
- 戰鬥失敗: 可選擇花費資源復活繼續，或是結束本次 Run 結算。
### 玩家從哪獲得爽快感?
- 農裝備、遺物、資源帶來的成長
- 賭博，看到金錢不斷增加
- 推進層數，挑戰更強敵人與更誇張的傷害數字。
- 類似 POE 的裝備改變機制導致的多樣玩法與組合
### 這個遊戲屬於
- 類單機遊戲，基本上是單機遊戲體驗，但需要後端作為權威伺服器。
- 同時 1000 人在台灣在線遊玩是可行的。需要登入才能玩。
## 新的一輪遊戲流程
- 選擇角色模板（決定職業與初始裝備）。
- 進入章節，顯示 10 個未知威脅等級節點。
- 每戰前可進入商店、下注血量區間、觸發賽前變數。
- 戰鬥自動進行，重播可任意拖動與變速。
- 勝利按下注結算倍率金幣，失敗進入 Run 失敗檢查。
## 總的來說 玩家能幹嘛?
- 玩家開啟一個新遊戲、然後選職業、或者有某些其他初始配置。
- 玩家在戰鬥之外:可以去商店、去賭博
- 玩家在戰鬥之外:可以管理裝備、查看自己狀態
- 玩家在戰鬥中:啥都不能做
- 玩家在戰鬥後:會開啟兩個獎勵分支，玩家選一個分支，每個分支都有兩個事件可以觸發。
- 玩家在進入事件後:回到戰鬥外狀態
- 循環往復
  w
## 個人偏好命名（保持可移植性）
### 正面例子
- Character、Entity、Creature、Combat、Encounter、Run、Equipment、Relic、Inventory、Shop 等。
### 反面例子（禁用）
- Gladiator、Noble、Arena 等綁定競技場詞彙。
----
FileRelativePath: instructions\遊戲介紹.instructions.md
# 遊戲機制大綱 - 2025/12/14
## 大致方向
### 故事背景
- 身為一名落魄貴族，你把手頭的錢都拿去買一名決鬥者，你將培養該決鬥者，在競技場挑戰強敵，賺取資源，重振家族榮耀。
### 遊戲核心概念
- 這個遊戲本質上是 RogueLite Run
- 資源下注挑戰隨機戰鬥，目標是存活到越後面越好.
### 鎖定的目標群體
- 輕度玩家、懶得操作的玩家。
- 上班摸魚、通勤無聊時間玩。
- 喜歡每次開局都不一樣的玩家。
- 喜歡改版頻繁的玩家。
### 玩家可以做什麼?
- 玩家操作極簡，符合輕度目標群（懶得操作），甚至懶得查攻略也該能玩。
- 開局: 選角色 + 其他配置
- 戰鬥外: 逛商店、賭博、管理倉庫與裝備、查看狀態
- 戰鬥前: 下注血量區間、觸發賽前變數
- 戰鬥中: 自動進行
- 戰鬥後: 勝利則選獎勵觸發事件（獲得獎勵或挑戰），然後循環回戰鬥外，否則進入戰鬥失敗處理流程
- 戰鬥失敗: 可選擇花費資源復活繼續，或是結束本次 Run 結算。
### 玩家從哪獲得爽快感?
- 農裝備、遺物、資源帶來的成長
- 賭博，看到金錢不斷增加
- 推進層數，挑戰更強敵人與更誇張的傷害數字。
- 類似 POE 的裝備改變機制導致的多樣玩法與組合
### 這個遊戲屬於
- 類單機遊戲，基本上是單機遊戲體驗，但需要後端作為權威伺服器。
- 同時 1000 人在台灣在線遊玩是可行的。需要登入才能玩。
## 新的一輪遊戲流程
- 選擇角色模板（決定職業與初始裝備）。
- 進入章節，顯示 10 個未知威脅等級節點。
- 每戰前可進入商店、下注血量區間、觸發賽前變數。
- 戰鬥自動進行，重播可任意拖動與變速。
- 勝利按下注結算倍率金幣，失敗進入 Run 失敗檢查。
## 總的來說 玩家能幹嘛?
- 玩家開啟一個新遊戲、然後選職業、或者有某些其他初始配置。
- 玩家在戰鬥之外:可以去商店、去賭博
- 玩家在戰鬥之外:可以管理裝備、查看自己狀態
- 玩家在戰鬥中:啥都不能做
- 玩家在戰鬥後:會開啟兩個獎勵分支，玩家選一個分支，每個分支都有兩個事件可以觸發。
- 玩家在進入事件後:回到戰鬥外狀態
- 循環往復
  w
## 個人偏好命名（保持可移植性）
### 正面例子
- Character、Entity、Creature、Combat、Encounter、Run、Equipment、Relic、Inventory、Shop 等。
### 反面例子（禁用）
- Gladiator、Noble、Arena 等綁定競技場詞彙。
