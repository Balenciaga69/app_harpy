# 技術架構與實現細節 - 2025/12/14

## 簡單來說

- 這是一個不斷修改 Context 狀態的邏輯處理器。輸入舊 Context ，應用業務規則，輸出新 Context 。 Context 驅動的設計。
- 代碼是無狀態的，代表著不同 Server Instance 間可以無痛切換，不會有使用者必須綁定在某一台 Server Instance 上的問題
- 代碼是可水平擴展的，代表著可以輕易增加更多 Server Instance 來應付高流量
- 這專案功能繁多，但不該有狀態保留在服務端的情況，同時代表服務不該存東西在本地端記憶體或檔案系統
- 要注意玩家可能會多裝置或多瀏覽器登入同一帳號(我們只允許一個紀錄事實)，因此所有狀態都必須存放在後端資料庫中，保證唯一真相

## 系統架構分層

### 前端分層

- **UI 層**：負責純顯示與用戶互動界面，例如按鈕、畫面渲染、動畫效果。不涉及業務邏輯。
- **邏輯層**：處理前端業務規則與狀態管理，例如玩家操作驗證、遊戲狀態計算、事件處理。與UI層分離，便於重用。
- **Fetch API 層**：統一處理數據請求與回應，無論開發階段（本地模擬）或上線階段（真API調用）。封裝網路邏輯，邏輯層透過此層獲取數據。

### 後端分層

- **API 層**：處理外部請求驗證、路由與中介邏輯，例如用戶登入、請求解析、錯誤處理。作為入口，呼叫遊戲核心層。
- **遊戲核心層**：專注處理遊戲邏輯與計算，不關心數據來源（API或直接調用）或儲存方式（Memory或DB）。接收 Context ，執行RUN、戰鬥、商店等操作，返回結果。

## 核心系統盤點

### 後端遊戲核心(你現在再處理的東西):

- RUN
- 關卡生成
- 敵人生成(也是角色的一種)
  - 實體模板
  - 動態變化
- 角色
- 職業
- 屬性
- 物品
  - 詞綴
  - 裝備
  - 裝備生成
  - 遺物與生成
- 戰鬥
  - 戰鬥的效果
  - 狀態
  - 聖火、中毒、充能、冰緩等異常狀態
- 大絕招或技能
- 戰鬥前事務
  - 下注
  - 賽前變數生成
- 戰鬥後事務
  - 獎勵事件派發與生成
  - 獎勵選擇與執行
- 難度係數系統
- 商店
- 賭博
- 倉庫

### 前端遊戲核心:

- 角色與裝備面板
- 戰鬥重播系統
- 商店與賭博介面
- 倉庫介面
- RUN 進程介面
- 戰鬥前下注與賽前變數介面
- 戰鬥後獎勵選擇介面

### 後端業務核心:

- 使用者系統(註冊、登入、權限)
- 儲存系統(RUN 狀態、使用者資料)
- 成就系統
- 統計系統

## 儲存系統設計

- 將整個 Run 的 Context 拆分成多個子 JSON 欄位（如角色屬性 JSON、倉庫 JSON、商店 JSON、路線分支 JSON 等），然後將這些欄位存入 NoSQL 資料庫（遊戲核心 NoSQL）。每個 Run 對應一筆記錄，多欄位允許精準更新與查詢。
  - 優點: 小操作（如商店購買）只需讀取/更新相關欄位（如倉庫 JSON），減少 IO 負擔，提升效能。
  - 優點: 支援索引查詢（如金幣欄位），易於找出當前金幣超過三十萬的 RUN，適合統計與分析。
  - 缺點: 欄位間一致性需額外處理（如交易確保多欄位同步），設計複雜度增加。
  - 缺點: 若欄位過多，記錄結構膨脹，仍可能影響載入速度。
- RDB 用於儲存需要高度一致性、交易性、以及明確關聯性的資料，例如帳號資訊、金錢餘額、成就進度等。(後端業務核心)
- 所有遊戲狀態，包括角色的配置與實例，只會在特定的生命週期內(例如一個請求)存在於伺服器的記憶體中。
- 儲存系統(不管 Redis,Pg,Mongo)扮演了遊戲世界的唯一真相

### 上下文分類(絕不存實體，只存模板與狀態，讓實際代碼去還原成物件)

- 角色資訊
- 倉庫
- 商店狀態
- 戰鬥(這個不存入持久)
- 戰鬥前事務
- 戰鬥後事務
- 關卡進程
- 敵人資訊
