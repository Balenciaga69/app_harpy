### 系統架構與軟體層面分析 潛在矛盾、衝突、不完善與空白點

基於提供的藍圖文檔（尤其是 affix.blueprint.md 作為核心，以及相關聯的 ailment.blueprint.md、character.blueprint.md 等），我從系統架構師的角度分析整體設計。重點關注一致性、耦合度、實作可行性、空白填補，以及軟體開發中的潛在問題（如狀態管理、擴展性、測試性）。設計整體強調解耦與無狀態，這是好事，但仍有幾處矛盾或不完善。以下按主題分類列出問題，並附簡要建議。

## 詞綴（Affix）層次結構與轉換邏輯的模糊性

### 問題

AffixTemplate（靜態藍圖）定義觸發條件 + 行為類型 + 參數，但轉換為 AffixInstance（運行時實例）時，如何處理「具體數值」（Rolled Value）？StatModifier（純數值修飾）如何從 AffixInstance 解析？文檔提及「影響屬性、運算方式（Added, Multi, More）」，但缺乏具體轉換規則（e.g., 一個 Affix 如何衍生多個 Modifier？條件觸發如「低於 50% 魔力」如何實作？）。這可能導致實作時邏輯混亂，屬性聚合系統難以統一處理。

### 衝突

與 ailment.blueprint.md 整合時，Affix 可附加狀態（如冰緩），但狀態實例（currentStack, currentDuration）如何與 StatModifier 區分？Affix 轉換為 Modifier 時，狀態效果是否也需解析為數值修飾？

### 建議

補充轉換管道（Pipeline）設計，定義明確的解析函數（e.g., `parseAffixToModifiers(affixInstance): StatModifier[]`）。確保條件觸發邏輯與事件系統（combat.blueprint.md）整合，避免硬編碼。

## 生成系統與池表的耦合與動態調整

### 問題

詞綴生成流程依賴詞綴池表（Affix Pool Table），但 generator-weight.blueprint.md 引入動態權重修飾符（e.g., Run Context 中的 JSON 陣列），這可能造成池表靜態定義與動態調整的衝突。如何確保權重調整後的 Roll 不破壞平衡？此外，難度係數（difficulty.blueprint.md）影響生成，但文檔未說明如何與池表整合（e.g., 難度提升時，是否動態篩選池內容？）。

### 空白

無盡模式（endless.blueprint.md）中敵人加入特殊 Affixes，但生成邏輯如何區分「僅此階段出現」？池表是否需支援階段標籤？

### 軟體層面問題

動態權重若存於 Run Context，可能導致狀態膨脹，影響序列化/反序列化效能。建議引入快取層或預計算邏輯。

## 角色與敵人作為 Unit 的不一致性

### 問題

character.blueprint.md 與 creature.blueprint.md 皆稱角色/敵人為 Unit，但角色有成長（裝備/遺物聚合），敵人由模板 + 生成參數決定，且「模板是死的，不會有 rolled 的問題」。然而，affix.blueprint.md 允許 Affix 附加到敵人（e.g., 無盡模式特殊 Affixes），這與「敵人模板死」的設計矛盾——若敵人有動態 Affix，如何保持模板靜態？

### 衝突

level.blueprint.md 中敵人模板可擔任 normal/elite/boss，但 Affixes 疊加方式不同。若 Affix 可附加，則敵人實例需支持動態修改，但文檔強調敵人「不會有 rolled 的問題」，這可能導致實作時被迫複製邏輯。

### 建議

明確區分「模板級 Affix」（靜態定義於敵人模板）與「實例級 Affix」（動態附加）。引入敵人生成器模組，統一處理模板 + 參數 + 動態 Affix，避免 Unit 類型過於抽象導致測試困難。

## 戰鬥系統與事件觸發的整合空白

### 問題

combat.blueprint.md 採用 Tick-based 設計，事件處理順序嚴格，但 Affix 的觸發（e.g., ON_HIT 事件）如何嵌入 Tick 流程？ailment.blueprint.md 提及狀態處理在特定 Tick 階段，但 Affix 行為（如 APPLY_STATUS）是否同步處理？若 Affix 觸發導致狀態變化，如何避免循環依賴（e.g., 狀態影響屬性聚合，反過來影響觸發）？

### 空白

事件監聽器（event listeners）如何註冊與觸發？文檔提及「事件管理器」，但未定義其架構。戰鬥重播（前端）如何處理這些事件，而不影響後端無狀態設計？

### 軟體層面問題

Tick 同步執行，若事件隊列過長，可能阻塞主執行緒。建議引入非同步事件處理或優先級隊列，並確保監聽器解耦（e.g., 使用中介者模式）。

## 儲存與持久化的狀態管理問題

### 問題

run.blueprint.md 強調 Run Context 存於儲存系統，但 AffixInstance 是運行時實例，如何持久化？若戰鬥中動態附加 Affix（如賽前變數），是否需存入 Context？stat.blueprint.md 分 Persistent Stats 與 Battle Stats，但未說明 Affix 屬於哪類，且異常狀態僅存於戰鬥 Context。

### 衝突

設計強調無狀態與水平擴展，但若 Context 包含動態數據（如 Affix 實例），可能導致版本不一致（e.g., 多設備登入時，舊請求處理舊狀態）。storage.blueprint.md 提及拆分 JSON 欄位，但未涵蓋 Affix 持久化。

### 建議

定義 AffixInstance 的序列化規則（e.g., 只存模板 ID + Rolled 值），戰鬥結束後清除動態部分。引入樂觀鎖或版本控制，避免衝突。

## 解耦原則的實作風險與測試性

### 問題

設計強調單向依賴（domain/app/adapter/infra），但 Affix 生成涉及多系統（池、難度、角色），可能形成隱藏耦合。e.g., 屬性聚合系統「不在乎 Affix」，但實際需解析 Modifier，這是否違反解耦？

### 軟體層面問題

TypeScript 實現需避免全局單例（instructions.md 禁止），但若使用事件總線，可能引入隱藏依賴。測試困難 Affix 行為模組若未模組化，單元測試難以隔離。

### 建議

強化介面定義（e.g., IAffixResolver），並使用依賴注入。補充行為模組的抽象層（e.g., EffectModule 介面），確保可替換與測試。

## 其他空白與擴展性問題

### 空白

ultimate.blueprint.md 中 Ultimate Gem 有 Affix 影響技能，但如何與 Affix 系統整合？pre-combat.blueprint.md 的賽前變數注入狀態，如何區分與 Affix？

### 擴展性

若新增 Affix 類型（如新運算方式），是否需改核心聚合邏輯？無狀態設計好，但若邏輯過於分散，可能增加維護成本。

### 建議

補充系統圖（e.g., UML 類圖），並定義擴展點（如插件式 Affix 行為）。整體而言，設計方向正確，但需更多實作細節（如介面定義、錯誤處理）以填補空白。

## 總結

設計有強大的解耦基礎，但轉換邏輯與動態元素需更明確定義，以避免實作時的混亂。建議優先補充轉換管道與事件系統的細節，並進行原型實作驗證。

## Affix 系統 你嘴上說「純粹」，但實際上已經被污染

- 你反覆強調 AffixTemplate 不關心出現時機、不關心擁有者、不關心地點
- AffixTemplate 內包含：
  - 觸發條件（eventType）
  - 行為（APPLY_STATUS / MODIFY_STAT）
  - 生效條件（如 HP < 50%）
  - Tags
  - 生成限制（等級、章節）
  - 這已經不是「純藍圖」，而是「半生成規則 + 半行為描述」
    真正的衝突是什麼？你同時存在三個地方在「決定 Affix 是否能作用」：
- AffixTemplate 定義生效條件
- AffixPool / Generator 定義是否能被抽中
- Context（Run / Difficulty / Endless） 動態修改可出現性
  你需要強制切一刀：AffixTemplate 只定義「如果它被啟用，會做什麼」
- 章節 / 等級限制
- 出現模式（Boss only / Endless only）
- 禁用規則
  - 全部集中到一個 AffixAvailabilityPolicy / RuleSet（生成層）

## 問題：Status 其實是「另一種 AffixInstance」

你嘴上說它們是不同系統，但從行為來看：有來源 有數值 影響屬性 影響行為 差別只剩「是否有 duration」
這會產生兩個實際問題：

## 問題：雙重聚合來源

你現在有：

- 裝備 → Affix → StatModifier
- 狀態 → Status → StatModifier

但誰負責最終一致性？

- Status Tick 後改變 Stat
- 屬性聚合階段又重新計算
- 那 Status 的影響是：
  - 永久寫回？
  - 還是每 Tick 重新套？

目前描述是模糊的。

## 問題：裝備改變異常狀態行為

你說：

> 裝備、遺物可改變異常狀態計算方式

那請問：

- 是 Affix 改變 Status Template？
- 還是改變 Status Instance 行為？
- 還是插手 Status System 的計算？

這三個選項架構差異極大，目前你沒有選清楚

### 建議一個乾淨解法

把 Status 明確降級成：

> 「有 duration 的 Modifier 容器」

也就是：

- StatusTemplate = ModifierTemplate + DurationRule
- StatusInstance = ModifierInstance + Timer

這樣：

- 屬性聚合永遠只吃 Modifier
- 不再有「狀態是否直接改 stat」的歧義
- Affix / Status 只是「來源不同」

這會讓你整個戰鬥層瞬間清爽很多。

## Combat Tick 流程：邏輯順序漂亮，但有一個致命漏洞

你現在的 Tick 順序是：

1. 行為轉 Event
2. Event 處理（傷害）
3. 狀態系統
4. 屬性聚合
5. 生死判定

### 問題：你在第 2 步用的是哪一版屬性？

因為你說：

- 狀態會影響屬性
- 但屬性是第 4 步才聚合

那請問：

- Damage Event 在第 2 步計算時：
  - 用的是上一 Tick 的屬性？
  - 還是「即時狀態修改後的屬性」？

這不是細節，是核心一致性問題。

### 極端案例（一定會遇到）

- ON_HIT → APPLY_CHILL
- Chill 降低敵人防禦
- 同一 Tick 內還有第二段傷害

請問第二段傷害有沒有吃到 Chill？

現在的描述兩種解釋都說得通，代表設計不完整。

### 你必須明確定義一個鐵則

例如其中一種：

- Tick 開始時鎖定 Snapshot Stats
- 本 Tick 所有 Event 都用這份
- 狀態只影響「下一 Tick」

或：

- 每個 Event 前重新聚合（成本高）

不選 = bug 溫床。

## Enemy / Boss / Endless：規則寫在模板裡，會害死你

你多次提到：

> 不同身份時 Affix 疊加方式寫在模板中

這在短期很方便，但長期一定爆。

因為：

- Endless mode 說「所有節點都是 Boss」
- 但 Boss 行為寫在 Enemy Template
- 那 Endless 是改模板？還是套規則？

模板是死的，模式是活的，不能反過來

建議你強制規則：

- EnemyTemplate：只描述「能力上限」
- EnemyRoleConfig（Normal / Elite / Boss / Endless）：描述加成規則
- Mode（Endless）只疊 RoleConfig

## 否則你會得到一堆 `if (isEndless && isBoss)`。

根據你提供的藍圖、指令與 shit.md 的分析，我再補充幾個目前藍圖設計上容易造成開發受阻或潛在危險的缺陷與空白：

---

## 1. **事件系統（Event System）抽象與一致性嚴重不足**

### 問題

- 藍圖多次提到「事件監聽」、「事件管理器」、「事件觸發」等，但沒有明確定義事件的結構、生命週期、註冊/反註冊機制。
- Affix、Status、技能等都依賴事件系統來觸發效果，但目前沒有一份統一的事件類型、資料結構、傳遞方式說明。
- 缺乏事件優先級、攔截、取消等進階機制，容易導致事件處理順序混亂或副作用難以追蹤。

### 風險

- 事件系統若未統一，會導致各模組各自為政，測試與除錯極困難。
- 事件循環依賴、重入、遺漏觸發等 bug 風險極高。

### 建議

- 需補充一份「事件系統藍圖」，明確定義事件類型、資料結構、註冊/觸發/取消流程，以及與 Affix/Status 的整合方式。

---

## 2. **屬性聚合與狀態影響的快照規則未明確**

### 問題

- stat.blueprint.md、combat.blueprint.md 都強調「屬性聚合」與「狀態影響」，但沒有明確定義「何時聚合」、「聚合結果快照是否貫穿整個 Tick」。
- shit.md 已指出這會導致傷害計算、狀態疊加等流程出現不一致。
- 目前沒有明確的「屬性快照」策略，會導致同一 Tick 內屬性變動難以追蹤。

### 風險

- 會產生「同一 Tick 內屬性前後不一致」的 bug，尤其在多段攻擊、連鎖事件下更嚴重。
- 前端重播與後端運算結果可能不一致。

### 建議

- 必須明確定義「屬性聚合快照」規則，並在 combat.blueprint.md 補充具體流程圖或時序圖。

---

## 3. **Affix/Status/Modifier 三者邊界模糊，缺乏統一解析管道**

### 問題

- Affix、Status、Modifier 都會影響屬性，但目前解析流程分散於多個藍圖，沒有一個「統一的解析/聚合管道」。
- Status 其實就是「有時效的 Modifier 容器」，但目前藍圖未強制統一，導致聚合邏輯重複、維護困難。

### 風險

- 新增/修改 Affix 或 Status 時，容易遺漏對應的聚合邏輯，產生隱藏 bug。
- 測試時難以覆蓋所有來源的 Modifier。

### 建議

- 應補充一份「Modifier 聚合藍圖」，明確規定所有來源（Affix/Status/賽前變數等）都必須經過同一解析管道。

---

## 4. **資料持久化與序列化規則不明確**

### 問題

- 多處提到「Context 持久化」、「AffixInstance/StatusInstance 序列化」，但沒有明確規範哪些欄位必須存、哪些只在運算時存在。
- 缺乏版本控制、欄位升級、兼容性設計。

### 風險

- 多設備同步時容易產生資料不一致、版本衝突。
- 未來資料結構變動時，舊存檔無法正確還原。

### 建議

- 應補充「Context/Instance 序列化規範」，並設計版本欄位與升級策略。

---

## 5. **生成系統與池表的動態調整規則過於分散**

### 問題

- generator-weight.blueprint.md、affix.blueprint.md、endless.blueprint.md 都有「動態權重」、「特殊池」等描述，但沒有一份統一的「生成規則藍圖」。
- 池表動態調整規則分散於多個 Context，缺乏統一入口。

### 風險

- 生成流程難以追蹤，容易出現「某些情境下池子異常」的 bug。
- 測試時難以覆蓋所有生成規則組合。

### 建議

- 應補充「生成系統藍圖」，統一描述池表、權重、動態調整、排他規則等。

---

## 6. **ACL（防腐層）與跨模組協作規則未明確**

### 問題

- 指令強調「防腐層」、「單向依賴」，但目前藍圖未明確哪些模組之間必須經過 ACL，哪些可以直接互調。
- 例如商店、倉庫、金幣、交易等系統協作流程未畫出。

### 風險

- 開發時容易違反單向依賴，產生循環依賴或隱藏耦合。
- 未來重構時難以拆分微服務。

### 建議

- 應補充「模組協作與 ACL 流程圖」，明確標註所有跨模組協作必經的防腐層。

---

## 7. **測試性與可觀測性設計嚴重不足**

### 問題

- 藍圖幾乎沒有提及「測試點」、「可觀測性」、「日誌結構」等設計。
- 事件、聚合、生成等流程都應有可插拔的測試點與日誌輸出。

### 風險

- 單元測試、集成測試難以覆蓋複雜邏輯。
- 線上 debug 時缺乏足夠資訊。

### 建議

- 應補充「測試與日誌設計藍圖」，明確每個核心流程的可插拔測試點與日誌格式。

---

## 8. **多設備/多用戶同步與衝突解決策略未明確**

### 問題

- 雖然多處提到「唯一權威」、「多設備同步」，但沒有明確描述「衝突解決」、「樂觀鎖」、「版本回滾」等策略。

### 風險

- 多設備同時操作時，容易產生資料競爭與損毀。

### 建議

- 應補充「多設備同步與衝突解決藍圖」。

---

## 9. **戰鬥重播與日誌結構未定義**

### 問題

- 前端重播依賴後端日誌，但目前沒有明確定義日誌格式、事件序列、快照點等。

### 風險

- 前後端重播結果不一致，難以 debug。

### 建議

- 應補充「戰鬥日誌與重播藍圖」。

---

## 10. **技能（Ultimate/Skill）與 Affix/Status 的互動規則未明確**

### 問題

- ultimate.blueprint.md 提到「技能可被 Affix 影響」，但沒有明確定義技能、Affix、Status 三者的互動與聚合規則。

### 風險

- 技能擴展時容易產生邏輯重疊或遺漏。

### 建議

- 應補充「技能系統藍圖」，明確技能與 Affix/Status 的聚合與觸發流程。

---

# 總結

## 目前藍圖雖有豐富的概念，但在「事件系統」、「屬性聚合快照」、「資料持久化」、「生成規則」、「ACL」、「測試性」、「多設備同步」、「戰鬥日誌」、「技能聚合」等關鍵基礎設計上仍有明顯空白或模糊，這些若不補齊，開發過程將極易受阻或產生難以維護的技術債。建議優先補足上述藍圖段落，並以 UML/流程圖/範例 JSON 等方式明確化。

以下是進一步從資深架構師與遊戲設計師角度，針對現有藍圖與指令，補充更深層、容易被忽略但極具風險的缺陷與空白，供你明天一口氣思考：

---

## 11. **「Context」膨脹與耦合風險**

### 問題

- Context 被設計為所有狀態的唯一真相，但目前所有動態權重、賽前變數、戰鬥狀態、物品、詞綴、敵人生成參數等都往 Context 塞，導致 Context 結構極度複雜。
- 缺乏 Context 的分層與聚合策略，Context 變成「大雜燴」。
- Context 欄位間的依賴與一致性規則未明確，容易出現「某欄位改了，另一欄位沒同步」的 bug。

### 風險

- Context 版本升級、資料遷移、跨服務同步時極易出現資料遺失或錯誤。
- 開發人員難以理解 Context 內部結構，維護成本高。

### 建議

- 補充 Context 分層與聚合規則，明確哪些屬於「持久層」、哪些屬於「戰鬥臨時層」。
- 設計 Context Schema 版本管理與自動升級機制。

---

## 12. **「池系統」與「生成規則」的可擴展性與熱更新問題**

### 問題

- 池表與生成規則目前多為靜態 JSON 或硬編碼，缺乏熱更新、動態調整、A/B Test、活動期間特殊規則等設計。
- 沒有「池規則插件」或「生成策略注入」的設計，導致每次要改規則都要重啟服務或改主程式。

### 風險

- 活動、平衡調整、bug 修正時，無法即時修正或回滾，運營風險高。
- 池規則複雜化後，測試與驗證困難。

### 建議

- 設計池系統的「策略模式」與「熱更新接口」，允許運營期快速調整。
- 池規則與生成策略應可配置、可測試、可回滾。

---

## 13. **「異常狀態」與「詞綴」的疊加規則與上限未明確**

### 問題

- 沒有明確定義同一類型異常狀態（如多個 Chill 來源）如何疊加、覆蓋、刷新持續時間。
- 詞綴與狀態的「疊加上限」、「優先級」、「互斥規則」未明確。
- 沒有「狀態黑名單/白名單」或「詞綴互斥組」的設計。

### 風險

- 玩家可利用疊加漏洞創造超強組合，破壞平衡。
- bug 難以追蹤，尤其是多來源同時作用時。

### 建議

- 補充「疊加規則表」、「互斥組設計」與「疊加上限」策略。

---

## 14. **「技能系統」與「詞綴/狀態」的資料流與責任分界不清**

### 問題

- 技能（Ultimate/Skill）本身可被 Affix 影響，但技能的「冷卻」、「能量消耗」、「效果」等責任分界不清。
- 技能效果與詞綴、狀態的資料流未明確，容易出現「技能效果被多次修飾」或「修飾順序錯亂」的問題。

### 風險

- 技能擴展時，容易出現「技能效果與詞綴效果重疊」或「技能效果失效」的 bug。
- 技能平衡難以維護。

### 建議

- 補充「技能資料流圖」與「技能-詞綴-狀態」責任分界說明。

---

## 15. **「戰鬥模擬」與「真實戰鬥」一致性驗證機制缺失**

### 問題

- 前端重播、後端模擬、測試用戰鬥模擬器等，若演算法、隨機種子、事件順序有一絲不一致，將導致「重播不同步」或「測試結果與真實不同」。
- 缺乏「一致性驗證」與「重播快照比對」機制。

### 風險

- 玩家回報 bug 時難以重現，運營與客服壓力大。
- 測試自動化難以驗證真實戰鬥結果。

### 建議

- 設計「戰鬥快照」與「重播驗證」工具，並強制所有戰鬥流程可 deterministic replay。

---

## 16. **「數值平衡」與「成長曲線」的可視化與驗證缺失**

### 問題

- 雖然有難度係數與生成規則，但缺乏「數值成長曲線」的可視化、驗證、壓力測試工具。
- 沒有「自動化數值驗證」與「極端案例模擬」設計。

### 風險

- 遊戲後期數值爆炸、早期過難或過簡，玩家體驗斷層。
- 運營期平衡調整困難，需大量人工測試。

### 建議

- 設計「數值驗證腳本」與「成長曲線可視化工具」，並定期自動化壓力測試。

---

## 17. **「玩家行為追蹤」與「異常偵測」機制缺失**

### 問題

- 沒有設計「玩家行為日誌」、「異常行為偵測」、「作弊防護」等機制。
- 缺乏「事件追蹤 ID」、「操作快照」等設計。

### 風險

- 玩家利用 bug 或外掛獲取不當利益，難以追蹤與修正。
- 運營期難以分析玩家流失或異常行為。

### 建議

- 補充「行為日誌」、「異常偵測」與「追蹤 ID」設計。

---

## 18. **「多語系/地區化」與「資料結構」分離未規劃**

### 問題

- 物品、詞綴、技能、狀態等描述目前多為靜態欄位，未設計多語系/地區化資料結構。
- 缺乏「本地化資源分離」與「多語系熱更新」設計。

### 風險

- 未來國際化時需大規模重構。
- 本地化 bug 難以修正。

### 建議

- 設計「本地化資源分離」與「多語系資料結構」。

---

## 19. **「運營活動」與「限時規則」的可插拔性不足**

### 問題

- 沒有設計「限時活動」、「特殊掉落」、「活動專屬詞綴/敵人/事件」的可插拔規則。
- 活動規則與主流程耦合，難以快速上線或下架。

### 風險

- 活動期 bug 難以修正，活動結束後殘留資料污染主流程。

### 建議

- 設計「活動規則插件」與「活動資料隔離」機制。

---

## 20. **「資料一致性」與「分散式鎖」機制未明確**

### 問題

- 多設備、多服務同時操作時，資料一致性與分散式鎖策略未明確。
- 缺乏「分散式鎖」、「操作佇列」、「衝突回滾」等設計。

### 風險

- 高併發時資料競爭，產生損毀或丟失。

### 建議

- 補充「分散式鎖」與「一致性協議」設計。

---

## 21. **「玩家體驗」與「可用性」驗證機制缺失**

### 問題

- 沒有設計「新手引導」、「容錯提示」、「操作回饋」等玩家體驗驗證流程。
- 缺乏「可用性測試」與「玩家反饋收集」機制。

### 風險

- 玩家流失率高，bug 難以發現。

### 建議

- 補充「體驗驗證」與「反饋收集」設計。

---

## 22. **「資料結構」與「業務邏輯」分離不徹底**

### 問題

- 多處資料結構與業務邏輯混雜（如 AffixTemplate 既有生成規則又有行為描述）。
- 缺乏「純資料結構」與「純邏輯模組」分離。

### 風險

- 未來資料結構調整時需同步調整邏輯，維護困難。

### 建議

- 強化「資料-邏輯分離」原則，並補充相關設計圖。

---

## 這些問題若不及早補足，將在專案規模擴大、運營期、國際化、活動期、平衡調整、bug 修正等階段造成極大阻礙。建議逐一列入藍圖補完與設計審查清單，並以「可測試、可維護、可擴展、可運營」為最高原則。

你可以參考以下理論、設計模式與業界成熟方案，這些在遊戲後端、分散式系統、Roguelite/卡牌/自動戰鬥類遊戲等領域都被廣泛應用，能有效解決你目前藍圖遇到的架構與可維護性問題：

---

## 1. **事件系統（Event System）/ 事件驅動架構（EDA）**

- 參考：Unity Event System、Node.js EventEmitter、Domain Events（DDD）、Observer Pattern、Command Pattern
- 重點：事件類型嚴格定義、事件資料結構標準化、註冊/反註冊/優先級/取消/冒泡、事件快照與重播
- 實作參考：mitt（TS）、RxJS、C# Event Aggregator

## 2. **屬性聚合與快照（Snapshot）**

- 參考：POE Stat Aggregation Pipeline、RPG Maker Stat Calculation、Functional Reactive Programming
- 重點：每個 Tick/Frame 聚合一次，聚合結果快照，所有運算基於快照，避免中途變動
- 實作參考：Immutable.js、Redux（State Snapshot）、Event Sourcing

## 3. **資料驅動設計（Data-Driven Design）**

- 參考：Unity ScriptableObject、POE Data Tables、JSON/YAML 配置驅動
- 重點：所有規則、池、生成、條件、行為都資料化，邏輯與資料分離，方便熱更新與平衡

## 4. **組件化設計（Component-Based Architecture）**

- 參考：Unity ECS、Entity-Component-System（ECS）、Component Pattern
- 重點：Unit/Entity 由多個可插拔組件構成，Affix/Status/Skill 都是組件，易於擴展與測試

## 5. **策略模式（Strategy Pattern）與插件架構（Plugin Architecture）**

- 參考：POE Modifier Calculation、Blizzard Hotfix System、Spring Plugin
- 重點：生成規則、池調整、活動、技能效果等都可用策略/插件注入，方便熱更新與A/B Test

## 6. **防腐層（Anti-Corruption Layer, ACL）/ 限界上下文（Bounded Context）**

- 參考：Domain-Driven Design（DDD）、微服務架構
- 重點：跨模組/微服務協作必經 ACL，防止外部變動污染核心模型

## 7. **資料一致性與分散式鎖（Optimistic Locking, Distributed Lock）**

- 參考：DynamoDB Conditional Write、MongoDB Version Field、Redis Redlock
- 重點：多設備/多服務同時操作時，樂觀鎖/版本號/分散式鎖確保資料唯一真相

## 8. **事件溯源（Event Sourcing）與重播（Replay）**

- 參考：CQRS/Event Sourcing、POE Combat Log Replay、Slay the Spire Replay
- 重點：所有狀態變化記錄為事件序列，可重播還原，方便 debug 與一致性驗證

## 9. **測試性與可觀測性（Testability & Observability）**

- 參考：Hexagonal Architecture、Test-Driven Development（TDD）、Structured Logging
- 重點：所有流程可插拔測試點、日誌結構化、可追蹤每一步狀態變化

## 10. **資料版本管理與升級（Schema Versioning & Migration）**

- 參考：Protocol Buffers、Avro、MongoDB Schema Version、POE Save Migration
- 重點：Context/Instance 持久化需有版本欄位，升級策略明確，兼容舊資料

## 11. **遊戲平衡與數值驗證（Game Balance & Simulation）**

- 參考：POE Simulation Tools、Slay the Spire Simulator、Auto Chess Simulator
- 重點：自動化數值驗證、極端案例模擬、成長曲線可視化

## 12. **資料本地化與國際化（i18n/l10n）**

- 參考：Unity Localization、POE Data Tables、React-i18next
- 重點：資料結構與本地化資源分離，支援多語系熱更新
