恭喜你，我們有全新的任務
將檔案名稱通通改成 PascalCase 命名法 且 檔案名稱 = 內容名稱
包含以下檔案: (用ps1腳本)
先檢查內容是否符合命名規則
符合就跳過
就寫入以下區塊 檔案位置: 檔案名稱 => 應該為的檔案名稱

```區塊寫入區

```

參考語法

```ps1
param (
    [string]$RootPath = "src/features/combat/interfaces"
)

$filesToRename = @()

function Get-ExportedName {
    param ([string]$filePath)

    $content = Get-Content $filePath -Raw
    if ($content -match 'export\s+(class|interface|type)\s+(\w+)') {
        return $matches[2]
    }
    return $null
}

function IsPascalCase {
    param ([string]$name)
    return $name -cmatch '^[A-Z][a-zA-Z0-9]*$'
}

Get-ChildItem -Path $RootPath -Recurse -Filter "*.ts" | ForEach-Object {
    $filePath = $_.FullName
    $fileName = [System.IO.Path]::GetFileNameWithoutExtension($filePath)
    $exportedName = Get-ExportedName -filePath $filePath

    if ($exportedName -and (IsPascalCase -name $exportedName)) {
        if ($fileName -ne $exportedName) {
            $filesToRename += @{
                Path = $filePath
                CurrentName = $fileName
                NewName = $exportedName
            }
        }
    }
}

Write-Host "Files to rename:"
$filesToRename | ForEach-Object {
    Write-Host "$($_.Path): $($_.CurrentName).ts => $($_.NewName).ts"
}

# Now rename the files
$filesToRename | ForEach-Object {
    $newPath = [System.IO.Path]::Combine([System.IO.Path]::GetDirectoryName($_.Path), "$($_.NewName).ts")
    Rename-Item -Path $_.Path -NewName "$($_.NewName).ts" -Force
    Write-Host "Renamed $($_.Path) to $newPath"
}

# PowerShell script to update import statements after renaming interface files

$renameMap = @{
   'attribute-owner'    = 'IAttributeOwner'
}

function Update-Imports {
   param ([string]$filePath)

   $content = Get-Content $filePath -Raw
   $updated = $false

   foreach ($oldName in $renameMap.Keys) {
      $newName = $renameMap[$oldName]
      # Replace import paths like './oldName' to './newName'
      $pattern = "'\./$oldName'"
      $replacement = "'./$newName'"
      if ($content -match $pattern) {
         $content = $content -replace $pattern, $replacement
         $updated = $true
      }
      # Also handle double quotes
      $pattern = '"\./$oldName"'
      $replacement = '"./$newName"'
      if ($content -match $pattern) {
         $content = $content -replace $pattern, $replacement
         $updated = $true
      }
   }

   if ($updated) {
      Set-Content -Path $filePath -Value $content
      Write-Host "Updated imports in $filePath"
   }
}

Get-ChildItem -Path "src/features/combat/interfaces" -Recurse -Filter "*.ts" | ForEach-Object {
   Update-Imports -filePath $_.FullName
}
```
