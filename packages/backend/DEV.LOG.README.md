# 摘要

## _2025/12/30_

- 完成商店與商品系統開發
- 更改遊戲失敗機制, 轉移至 TFT 那種扣血而非 Hades 死了就本 Run 結束

## _2025/12/29_

- 重新建造 Stash,Character 等服務
- 修正需多預先設想太美好而導致的豐富物件錯誤與過度複雜邏輯

## v0.5.0

- 寫好 Repo Pattern, Result Pattern, Context Manager, Factory Pattern, Generator, DataMapper, Template/Record/Aggregate 等等基礎架構
- 實作 角色, 遺物, 穿戴裝備系統
- 開發各種基礎 Domain 物件
- v0.4 版不兼容變更

## _2025/12/28_

- 修補升級豐富模型後的錯誤程式碼。

## _2025/12/27_

- 原本只留 id 去查找的模式, 雖然解耦但問題浮現
  - 必須在 app 層中，手動查找每個 affixInstance 的 template、effectIds、effectTemplate，然後再組裝 statModifiers。
  - 每次都要從 context 拿到 relics，再從 relics 拿 affixInstances，再從 affixInstances 拿 templateId，再查 affixStore。
  - 若未來 affix 或 effect 的規則變動，必須修改 service 層的多層查找與組裝邏輯，違反開放封閉原則。
  - 單元測試也變得困難，因為必須 mock 多層 store 與資料結構。
- 解決方案：
  - 升級為豐富模型，包含完整模板、詞綴、效果，專責業務邏輯與計算。
  - 持久化物件改名為 Context，查詢後組裝成豐富模型。
- 生成工廠函數改為 class，方便擴展與繼承。

## _2025/12/26_

- 構思單元測試與 AI 品質檢查關卡
- 建立大量空殼與單元測試，確保 AI 品質檢查可運作
- 添加指令，從傳統乾淨代碼工法轉為 AI 優先驅動

## _2025/12/25_

- 研究 Go、C#、Ts 的開發哲學並應用於專案
- 建立庫存系統的領域物件與服務

## _2025/12/24_

- 構思啟動器、載入器與遊戲初始化流程
- 研究抽象層級不一致、業務流程協調等代碼異味

## _2025/12/23_

- 統一命名生成器為工廠與創造方法
- 思考類別依賴注入與函數屬性傳遞的取捨

## _2025/12/22_

- 權衡全局單例與 Prop Drilling 機制
- 研究 Balatro 機制
- 研究以穿戴負載值取代裝備與聖物系統

## _2025/12/21_

- 構思物品生成流程、權重與動態調整機制

## _2025/12/20_

- 確立版本 v0.5

## _2025/12/19_

- 建立 Run, Nodes, Enemy, Event 各種模板與生成機制

## _2025/12/18_

- 研究 Backpack Battles 與 Skill Legends Royale 的異常狀態（Aliment）處理方式
- 重新定義關卡「事件」與節點配置
- 詢問 GPT 以下機制簡化整合的可行性：
  - Slay the Spire、Monster Train 的地圖分支、資源管理、戰利品節奏、隨機事件
  - Risk of Rain 2 的遺物系統
  - LoL TFT 的奇遇與增幅裝置
  - Path of Exile 的傳奇裝備模板、頭盔附魔、固定詞綴（Affix）與修正項（Modifier）、裝備欄位
  - Skill Legends Royale 的能量獲取、自動施放大招（Ultimate）、Tick-based 1v1 自動戰鬥
  - Backpack Battles 的異常狀態堆疊（不導入背包放置）

## _2025/12/17_

- 深度思考 Affix, Modifier 領域相關問題與如何實現生成系統
- 思考從原本的 PoE-like Roll 裝備系統與 LoL 的固定裝備系統, 哪種更適合 Rogue-like 遊戲

## _2025/12/16_

- 繼續重新思考以及補足我的架構藍圖以及每個元件的職責

## _2025/12/15_

- 反思現有架構的維護困難點
- 與 AI 討論庫存系統需求
- 將舊內容歸檔
- 暫停寫碼，重新規劃方向
- 決定主要手刻後端邏輯，僅少量輔以 AI 生成

## _2025/12/14_

- 思考前後端分離時的重構需求
- 探索通用前後端溝通方案
- Claude Sonnet 4.5 生成庫存、角色管理、敵人系統

### v0.4.4

- AI 生成代碼:PreCombat, ShopGambling, Enemy, CharacterManager

## _2025/12/13_

- 修補其他模組重構後的糟糕代碼, 代碼多到想吐, 修改了兩百多個檔案
- Claude 處理了 80% 的重構令人感到驚訝

### v0.4.3

- 用乾淨分層變體架構整個大重構
- 添加 DDD 邊界限制, eslint 與 monorepo 結構

## _2025/12/12_

- 嘗試重構了一個 combat 後, 考慮放棄遵循嚴格 DDD, 這對目前開發階段的幫助不大, 反而增加開發成本
- 重修構思一個版本, 一樣用 infra/interfaces/app/domain 分層, 但一切引用 interfaces 而非實作 (非傳統乾淨分層)
- 這種分層更類似通通依賴介面強制約束, 但不像乾淨分層那樣嚴格區分依賴方向
- 一切依賴介面與注入, 同時默許介面層逐漸膨脹, 未來有需要再拆分模組

## _2025/12/11_

- 將 combat 模組率先分成乾淨架構後, 發現有一堆違反依賴規則的地方

### v0.4.3

## _2025/12/10_

### v0.4.2

- 重新思考 Item, Affix 與 Effect 的關係
- 重構 Item 模組與 Effect-System 模組
- 建立商店模組
- 建立第一個職業戰士角色範例與對應的裝備池
- 建立裝備生成系統

## _2025/12/09_

## _2025/12/08_

- 從 combat 抽離屬性, 效果, 裝備等邏輯, 遷移到 domain 模組
- 重新定義 combat 為一個屬性, 效果, 大招交織的戰鬥運算引擎

### v0.4.1

- 移除 combat 中定義的 attribute, effect, item 等領域邏輯
- 新增 domain 內容的適配器與對應代碼
- 新增 domain/item 模組, 把裝備, 遺物, 詞綴相關邏輯獨立出來
- 重構 logic/combat 模組, 移除與裝備, 遺物, 詞綴領域相關的邏輯
- 新增 domain/character, attribute 模組, 把角色與屬性相關邏輯獨立出來

## _2025/12/07_

- 盤點領域資料內容, 現在開發其他模組發現 Combat Engine 裡面有很多重複的東西
- 打算新建 domain/item 模組, 專門處理裝備, 遺物, 詞綴等相關邏輯以便未來生成裝備／庫存／戰鬥使用

### v0.4.1

## _2025/12/06_

- 開始以先寫規格書與 TODO 的方式規劃新模組
- 開始評估是否要在此階段添加單元測試 (Combat, Replay 已經定型)
- 添加了 License 到專案, 在我搞懂法律與授權之前先一律禁止嚴格商業用途 (本專案目的是作品集與自用)
- 構思戰前變局系統 (TFT 戰棋開局奇遇)與復活系統 (HP 歸 0 後有機率復活)
- 構思生成道具, 地圖, 路線等等系統的基礎架構

### v0.4 (run, license, combat)

- 新增 Run 模組骨架
- 新增 LICENSE 檔案, 禁止商業用途
- 新增復活系統
- 新增賽前變數注入系統
- 新增血量歸零, 血量低於某值事件掛勾

## _2025/12/05_

- 探討純函數 ECS 與 OOP 開發上的差異
- 研究 immer.js 與純函數 (最終放棄導入)
- 研究不使用 Global Singleton 的依賴注入模式的原因 (單例測試困難, 跨語言移植, 多實例支援)
- 被眾多理由說服, 不考慮用純函數 + ECS + immer.js 的方式來實作本專案

### v0.3.1 (combat, replay)

- 新增 CharacterBuilder, 讓建立角色更方便
- 將 BattleState 從 CombatContext 中拆分出來, 讓系統對戰鬥過程的數據追蹤更集中, 更單純
- 預計在 v0.4 從物件導向設計改為資料驅動的不可變純函數版本, 讓狀態溯源, 複雜邏輯交互更好追蹤
- 新增 Error Handling 與更詳細的事件日誌
- Replay 模組極度簡化功能, 僅保留開始, 暫停, 繼續, 結束, 倍速設定等功能

## _2025/12/04_

- 繼續構思與修正 Replay 模組, 並對 AI 生成的代碼進行 Code Review
- 上班太累, 懶得更深入思考新的業務邏輯, 做些簡單的事情

## _2025/12/03_

- 權衡 mitt 與同步嚴格性在我的 combat 模組中的用途與意義
- 重新構思效果系統與疊層機制
- Code review AI 生成的回放系統與戰鬥範例

### v0.3.1 (combat)

- 目的:統一管理資源, 遵循單一職責原則, 維持乾淨代碼
- 把角色屬性和效果的程式碼拆分得更細, 讓每個小區塊的功能更專一
- 重新檢查了所有檔案和變數的名稱, 讓它們的命名更符合專案標準
- TickActionSystem 現在可以把一個複雜的動作 (如:放一個大招)拆成幾個更小的階段 (Phase 拼裝), 這讓戰鬥邏輯的控制更精準, 更有彈性

## _2025/12/02_

- 回放系統交由 AI 自動生成初版, 雖然還沒檢視效果, 但預感不妙, 後續需要打磨
- 開始反思循環依賴與多個 combat 元件之間的關係, AI 自動生成的部分有些混亂, 考慮導入洋蔥架構並以 eslint 約束依賴邊界

### v0.3 (combat)

- 目的:降低耦合度, 解決物件循環依賴問題, 統一管理資源, 遵循單一職責原則
- 戰鬥邏輯與角色屬性原本綁得太緊, 拆解它們之間的關聯, 讓戰鬥系統可以獨立運作, 為未來擴展打好基礎
- 將 AbilitySystem 與 Tick 功能整合為 TickActionSystem, 使其更貼合 Tick 機制的實際運作
- 引入資源 Registry 作為中央資源管理系統, 所有角色, 裝備, 大招等都必須透過 Registry 查找與調用, 避免私下耦合
- 把 TickActionSystem 拆成「每 Tick 發出/處理訊號」兩個核心元件
- 加入更多細緻的「戰鬥流程檢查點 (CombatHooks)」, 未來新增或修改戰鬥中的特殊判定 (例如:閃避, 格檔)會更方便

## _2025/12/01_

- 開始思考數值與屬性, 並參考 TFT, Backpack Battles, Skill Legends Royale 的定位與數值邏輯, 也開始規劃大招特性的核心方向
- 重新檢視分層架構與單向依賴, 降低模組耦合度
- 導入物品系統與大招系統

### v0.3 (combat)

- 新增物品、大招系統
- 重構代碼，提升模組獨立性與維護性

## _2025/11/30_

- 今天是禮拜日, 終於完成了基於 Tick 機制的戰鬥系統初步原型 為了支援複雜非線性戰鬥邏輯, 複雜度遠超預期 我原本希望實現類似《Path Of Exile》中「物理傷害轉為火焰傷害」, 「承受冰傷害視為毒傷害」, 或「暴擊時觸發兩次運算」之類的特殊規則, 結果在架構設計與數據模型上花了大量時間打底
- 開發過程中, 我負責整體架構設計, 數據模型繪製, 以及各種設計模式與架構取捨；Copilot 生產了約 99% 程式碼, 我只需做最後的修整與整合
- 一開始構想很單純:建立一個每 Tick 發事件, 每 Tick 收事件的 Queue 系統, 再以事件優先級決定執行順序, 藉此模擬複雜戰鬥邏輯 實作後才發現管理成本高得離譜, 因此決定重構成 v0.2
- 在開發到一半時, 我重新審視遊戲整體機制 研究 TFT, Backpack Battles, Skill Legends Royale 等作品後, 發現它們的輕量化核心更符合我專案目前的方向, 因此決定從遊戲設計層面重新調整戰鬥系統的根本理念
- 調整方向包括:導入「大招系統」, 並移除或大幅簡化複雜的元素抗性與多重傷害轉換 所幸前期架構保持乾淨, 模組化, 變更影響被控制在合理範圍內

### v0.2 (combat)

- 由於發現原本 PoE 的複雜傷害計算, 在目前量級超難做, 而且也不有趣, 所以往讓戰鬥機制更輕量, 更直覺的方向前進
- 用更簡單的事件觀察者模式取代原本的事件隊列系統, 降低複雜度
