# 生成與池表系統

## 1. 生成系統與池表的耦合與動態調整 ⚠️

### 問題

詞綴生成流程依賴詞綴池表（Affix Pool Table）

但 generator-weight.blueprint.md 引入**動態權重修飾符**（e.g., Run Context 中的 JSON 陣列）

### 衝突

這可能造成：

- **池表靜態定義** vs **動態調整**的衝突
- 權重調整後的 Roll 不破壞平衡？
- 難度係數（difficulty.blueprint.md）影響生成，但文檔未說明如何與池表整合

### 實際案例

```typescript
// 池表：靜態定義
const AffixPool = {
  chill: { weight: 10 },
  freeze: { weight: 5 },
  stun: { weight: 8 },
}

// 但運行時被改了
// Context 說：Endless 模式下，Stun 權重提升 50%
// 那最後的池表是什麼？

// 場景 1：套疊（Endless 的 stun 是 12 而不是 8）
const runtimePool = {
  chill: { weight: 10 },
  freeze: { weight: 5 },
  stun: { weight: 12 }, // 8 * 1.5
}

// 場景 2：完全替換（Endless 用完全不同的池）
const endlessPool = {
  chill: { weight: 15 },
  stun: { weight: 20 },
  // freeze 消失了
}

// 問題：沒人說是哪個
```

### 空白

無盡模式（endless.blueprint.md）中敵人加入特殊 Affixes

但：

- 生成邏輯如何區分「僅此階段出現」？
- 池表是否需支援階段標籤？

```typescript
// 要支援這些場景嗎？
const AffixPool = {
  normalAffixes: [...],

  // 章節限制
  chapter1Only: [...],
  chapter5Plus: [...],

  // 敵人類型限制
  bossOnly: [...],
  normalEnemyOnly: [...],

  // 模式限制
  endlessOnly: [...],
  challengeOnly: [...],
};
```

### 軟體層面問題

動態權重若存於 Run Context，可能導致：

- **狀態膨脹**：Context 越來越大
- **序列化效能問題**：每次存檔都要序列化複雜的權重修飾
- **版本衝突**：多設備同步時，權重定義不一致

### 建議

**補充「生成系統藍圖」**

統一描述：

- 池表定義與類型
- 權重修飾的應用方式
- 動態調整的規則
- 排他規則（某些 Affix 不能同時出現）
- 階段/難度/模式的影響

**範例架構：**

```typescript
// 層 1：靜態池定義
interface AffixPoolDefinition {
  id: string
  affixes: Array<{
    affixId: string
    baseWeight: number
    tags: string[] // 用於動態過濾
  }>
}

// 層 2：動態調整規則
interface PoolModifier {
  condition: {
    chapter?: number
    difficulty?: number
    mode?: GameMode
    roleRestriction?: EnemyRole
  }

  // 應用方式
  application: 'multiply' | 'add' | 'replace' | 'filter'

  // 修飾內容
  weights?: Record<string, number>
  tagsToInclude?: string[]
  tagsToExclude?: string[]
}

// 層 3：生成時查詢
class AffixGenerator {
  generate(context: GenerationContext): AffixInstance[] {
    // 取得基礎池
    const pool = this.getPool(context.chapter)

    // 套用動態修飾
    const modifiedPool = this.applyModifiers(pool, context)

    // 檢查排他規則
    const filtered = this.filterExclusions(modifiedPool)

    // Roll
    return this.roll(filtered, context.rollCount)
  }

  private applyModifiers(pool: AffixPoolDefinition, context: GenerationContext): AffixPoolDefinition {
    let modified = JSON.parse(JSON.stringify(pool)) // 深拷貝

    const modifiers = this.getApplicableModifiers(context)

    for (const modifier of modifiers) {
      switch (modifier.application) {
        case 'multiply':
          // 權重乘法
          for (const [affixId, weight] of Object.entries(modifier.weights || {})) {
            const entry = modified.affixes.find((a) => a.affixId === affixId)
            if (entry) entry.baseWeight *= weight
          }
          break

        case 'add':
          // 權重加法
          for (const [affixId, weight] of Object.entries(modifier.weights || {})) {
            const entry = modified.affixes.find((a) => a.affixId === affixId)
            if (entry) entry.baseWeight += weight
          }
          break

        case 'filter':
          // 過濾
          modified.affixes = modified.affixes.filter((a) => {
            const hasIncluded =
              !modifier.tagsToInclude?.length || modifier.tagsToInclude.some((tag) => a.tags.includes(tag))

            const notExcluded = !modifier.tagsToExclude?.some((tag) => a.tags.includes(tag))

            return hasIncluded && notExcluded
          })
          break
      }
    }

    return modified
  }
}
```

---

## 2. 難度係數與生成的整合模糊 ⚠️

### 問題

difficulty.blueprint.md 影響生成

但文檔未說明如何與池表整合

```
? 難度提升時，是否動態篩選池內容？
? 高難度專屬 Affix？
? 權重乘法？加法？還是完全替換？
```

### 建議

補充難度係數與生成的對應表

---

## 標記

- 核心問題：生成規則統一、權重管理
- 優先級：🟡 中 - 影響平衡與運營
- 相依模組：詞綴系統、難度系統、無盡模式
