# 商店模組

## 簡介

商店模組專注於交易與商品管理，提供購買/出售功能，並負責商品刷新與生成。模組與 ItemGenerator 緊密整合，生成裝備/遺物實例。儲存邏輯目前在前端實現，未來遷移至後端以支援跨平台同步。最後更新時間：2025/12/10，排除賭博邏輯（由 ShopGambling 處理）以維持單一職責。

## 輸入與輸出

### 主要輸入

- 玩家金幣數量（檢查購買力）。
- 當前難度係數（影響商品生成強度）。
- 玩家庫存清單（用於出售與空間檢查）。
- 章節層數（決定刷新規則與價格調整）。

### 主要輸出

- 商品清單（裝備/遺物實例與價格）。
- 交易結果（狀態更新，包括金幣與庫存變更）。
- 領域錯誤（例如金幣不足或庫存滿載）。

## 元件盤點

### ShopManager

核心控制器，處理購買/出售請求、觸發商品刷新。調用 ItemGenerator 生成商品，並整合事件總線通知庫存更新。

### PricingEngine

定價計算器，根據物品定義、難度係數與章節層數設定價格。買入價格動態調整，賣出價格為買入的折扣版。

### ItemGeneratorAdapter

生成適配器，直接橋接 ItemGenerator 以產生商品實例。根據難度篩選池子，確保商品適配當前進度。

### ShopErrorHandler

錯誤管理器，定義專屬領域錯誤（如 InsufficientFundsError），用於交易驗證失敗時拋出異常。

## 模組依賴誰?或被誰依賴?

### 依賴的模組

- ItemGenerator：生成商品實例（裝備/遺物），商店依賴其隨機生成邏輯。
- DifficultyScaler：提供難度係數以調整商品強度。
- Inventory：查詢/更新玩家庫存與金幣。
- RunOrchestrator：監聽事件以觸發刷新與價格變化。

### 被依賴的模組

- UI層：顯示商店介面與交易操作。
- PersistentStorage：儲存商品清單與狀態（目前前端實現，未來後端遷移以支援多裝置）。
- RunOrchestrator：商店作為 Run 流程節點，每戰勝利後刷新。

## 交易流程細節

- 購買：驗證金幣與庫存空間後，執行交易、更新狀態。若失敗，拋出錯誤。
- 出售：從庫存移除物品、計算價格、增加金幣。
- 刷新：基於章節事件自動觸發，調用 ItemGenerator 生成新商品清單。

## 儲存考量

- 目前前端儲存商品狀態，(這是前端邏輯負責，我們目前不處理)使用 localStorage 或 Zustand。未來後端遷移時，需設計 API 以同步商品清單，避免前端依賴。

## 未來擴充

- 支援商品過期機制或動態庫存。
- 與 ShopGambling 分離後，專注優化生成規則以提升遊戲平衡。

## 溝通機制

商店模組透過事件總線與直接介面調用與其他元件互動，確保資料一致性與鬆耦合。所有溝通均為同步操作，避免非同步複雜性。

### 與 Inventory 的溝通

- 查詢庫存：商店調用 Inventory 的 `getInventoryItems()` 方法，獲取玩家物品清單以檢查出售可用性。
- 更新庫存：購買時調用 `addItemToInventory(item)`，出售時調用 `removeItemFromInventory(itemId)`，並發佈 `InventoryUpdated` 事件通知 UI。
- 金幣管理：查詢金幣調用 `getPlayerGold()`，更新調用 `updatePlayerGold(amount)`，確保交易後立即同步。

### 與 ItemGenerator 的溝通

- 商品生成：刷新時調用 ItemGenerator 的 `generateEquipment()` 或 `generateRelic()` 方法，傳入難度係數與隨機種子，獲取實例後包裝為商品。

### 與 DifficultyScaler 的溝通

- 獲取難度：調用 `getCurrentDifficulty()` 方法，動態調整商品強度與價格。

### 與 RunOrchestrator 的溝通

- 事件監聽：訂閱 `ChapterAdvanced` 事件以觸發價格通膨，訂閱 `CombatVictory` 事件以刷新商品。

### 與 PersistentStorage 的溝通

- 儲存狀態：目前前端調用 `saveShopState(state)`，未來後端遷移為 API 調用以持久化商品清單。
