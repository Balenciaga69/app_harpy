---
applyTo: '**'
---

Provide project context and coding guidelines that AI should follow when generating code, answering questions, or reviewing changes.

# 遊戲機制與設計大綱（2025/12/01）

## 遊戲核心概念

- 單機即時制戰鬥 Roguelite，玩家配置角色、裝備、技能，挑戰層層關卡。
- 戰鬥以 tick 為單位，自動進行，玩家僅於戰前配置與選擇技能。Replay 的時候是以 1x速度播放，同時10ms = 1tick。
- 具備裝備、大絕招、遺物等多元養成與策略選擇。

## 戰鬥系統

### 1. 攻擊邏輯

- 僅分「普通攻擊」與「大招」兩種，無元素傷害規則。
- 普通攻擊有 cooldown（等待時間，單位 tick），大招需能量條充滿後釋放，無 cooldown。
- 能量條由角色屬性決定獲取速度，並有自然回復。
- 傷害分為「一般傷害」與「真實傷害 True Damage」（無視任何減免）。
- 異常狀態（聖火、燃燒、中毒、充能等）獨立於元素屬性，並可被裝備、角色、聖物等影響。
- 閃避與減免機制自訂，簡化公式，避免複雜計算。

### 2. 戰鬥流程

- 玩家與敵人依據冷卻時間自動執行行動。
- 主攻擊僅能有一種（武器或法術），法術必中、無暴擊，武器有命中與暴擊判定。
- 戰鬥結果於載入時即決定，過程不可干預。

### 3. 異常狀態與效果

- 異常狀態機制目前還在構思，可能會大改動
- 聖火、充能、冰緩、毒等異常狀態有各自疊加、減少、觸發規則。
- 無屬性異常如致盲、破甲、出血、褻瀆等，影響命中、護甲、生命等。
- 部分裝備、聖物可改變異常狀態的計算方式或效果。

## 角色與裝備系統

### 1. 屬性分層

- 防禦：HP、護甲（%減傷）、閃避（與命中值運算）。
- 攻擊：攻擊力、冷卻、暴擊率、命中值、攻擊標籤。

### 2. 裝備分類與機制

- 武器（或魔法書）、頭盔、裝甲、項鍊。
- 其實本質上都是遺物(Items)，只不過遺物可以無限堆疊，但裝備武器只能裝備一個。
- 遺物物品可能改變遊戲玩法，所以需要複雜運算鍊。
- 裝備有升級系統

## 關卡與進程

- 關卡分一般、小型 Boss、大型 Boss、正面事件。
- 層數遞增，怪物屬性依難度係數調整。
- 最高 30 關，每 5 關有中型 Boss，每 10 關有大型 Boss。
- 超過 30 關，則進入無盡模式，難度持續提升。

## 掉落與商店

- 每關結束可三選一獎勵（裝備、遺物）。
- 商店可隨時進入，購買物品。
- 物品價格被係數控制，隨關卡提升而通膨。

## 死亡與重試

- 玩家有 n 次死亡機會，失敗將回到戰鬥前，並且商店老闆會給你一個抽獎盲盒作為補償並刷新商店內容。

## (combat模組)分層架構設計

- 分層依賴：infra, context, domain, logic, coordination, combat-engine。
- 下層不依賴上層，保持低耦合、高內聚，易維護。
- 遊戲邏輯被分成 戰鬥與戰鬥外兩大部分。各自可以獨立運作，可以假設另一塊模組已經完成，無縫接軌。
- 遊戲邏輯不應依賴 UI 與 任何程式語言與框架。
- UI 基於遊戲邏輯驅動

---

### 已定型模組簡介

這裡包含各大已經完工模組的檔案結構與內容說明(多數細節（工廠、步驟實作、Builder、工具類等）視為底層實作，這裡只列出核心運作相關的 Class 與它們的主要責任。)

- combat: 負責戰鬥邏輯與運算
  - combatEngine: 封裝戰鬥流程控制與聚合結果，同時負責調度 ticker, ability, logger, snapshot 等子模組。就像是這場戰鬥背後總指揮官或場控導演。
  - TickerDriver: 就像是時鐘的主發條或節拍器，他會推進 tick，並觸發 tick start/end 以及 combat start/end 事件
  - EventLogger: 透過監聽來自 EventBus 的所有事件來被動記錄新增至 CombatLogEntry
  - CombatContext: 管理全域資源（EventBus、RNG、參戰實體、當前Tick），為各系統提供讀寫介面。
  - EventBus: 戰鬥內事件總線，負責事件發佈與訂閱（tick、攻擊、死亡等），讓系統以事件驅動溝通。
  - Character: 戰鬥中的實體（玩家或敵人），封裝屬性、裝備、遺物、效果與生命週期；對外暴露簡潔 API（屬性查詢、裝備、效果管理等）。
  - AttributeContainer / AttributeCalculator: 資料與計算分離，Container 保存 Base 屬性與 Modifier，Calculator 負責最終屬性值計算（加算/乘算/優先順序）。
  - EffectManager: 每個角色的效果管理器，負責新增/移除/更新效果並在 Tick 時驅動效果（onTick）。
  - TickActionSystem: 由 Tick 驅動的效果觸發、攻擊協作系統，負責攻擊節奏、目標選擇、能量/大招邏輯並呼叫 DamageChain 發起傷害流程。
  - DamageChain: 將完整的傷害運算拆為多個有序階段（Hit、Crit、DamageModify、Defense、Apply 等），以 Step 模式串接並允許提前終止。
  - SnapshotCollector: 監聽事件並在設定頻率收集戰鬥快照（用於回放與結果分析），只負責收集不參與邏輯。
  - 補充說明：多數細節（工廠、步驟實作、Builder、工具類等）視為底層實作，這裡只列出核心運作相關的 Class 與它們的主要責任。
- replay: 負責戰鬥回放與時間軸管理（回放邏輯獨立於 combat 運行，消耗 CombatResult 的 snapshots & logs）
  - ReplayEngine: 回放系統核心，載入 CombatResult，管理播放狀態（loaded/playing/paused/ended）、速度、seek、loop，並在每個播放 Tick 發出事件供 UI 或 Controller 使用。
  - ReplayEventEmitter: Replay 的輕量事件發佈器，提供復用的 pub/sub API，讓 UI 與 Controller 能夠訂閱回放事件。
  - PlaybackController: 封裝常用的播放跳轉操作（播放/暫停/跳至開頭/結尾、跳到下一次大招/死亡等），對外提供便捷 API。
  - TimelineController: 負責時間軸相關轉換與重要時刻偵測（Tick ↔ Progress，尋找大招/死亡/暴擊等重要事件，回傳 timeline marker）。
  - Replay models (ReplayConfig / ReplayState / ReplayEvent): 定義回放設定、內部狀態與事件類型，提供型別保證與設定預設值。
  - 補充：Replay 非侵入式，僅依賴 Combat 數據（snapshots/logs），邏輯上與 combat 引擎分離，能夠在 UI 層獨立使用，並支援速度控制與平滑插值（interpolation）。
