# 權衡利弊分析

## 1. 詞綴系統的設計權衡 ⚠️

### 選擇

affix.blueprint.md 選擇**靜態模板**以簡化邏輯

### 獲得

- ✅ 邏輯簡單
- ✅ 易於測試
- ✅ 易於平衡調整
- ✅ 預測性強

### 犧牲

- ❌ 隨機性不足
- ❌ 重玩價值下降
- ❌ 玩家新鮮感低

### 問題

**未評估對玩家體驗的長期影響**

```
長期風險：
- 玩家很快感到重複（所有詞綴組合是固定的）
- 無法應對活動期特殊詞綴需求
- 難以調整某個詞綴的強度（需改所有模板）
```

### 建議

考慮混合方案：

- 核心詞綴靜態預綁定
- 活動期間允許特殊詞綴池
- 或引入「詞綴變異」機制（同詞綴不同效果幅度）

---

## 2. 戰鬥系統的性能 vs 確定性 ⚠️

### 選擇

combat.blueprint.md 採用 **Tick 輪作與事件隊列**確保順序

### 獲得

- ✅ 確定性強（可重播）
- ✅ 行為可預測
- ✅ 易於除錯
- ✅ 前後端同步容易

### 犧牲

- ❌ 事件隊列可能過長
- ❌ 長戰鬥時性能開銷大
- ❌ 實時反應性差

### 問題

**未討論高併發或長戰鬥下的性能開銷**

```
風險案例：
- 無盡模式第 100 層
- 3 個玩家單位 + 30 個敵人
- 每 Tick 產生 200+ 事件
- 事件隊列處理時間？CPU？
```

### 建議

1. 設計事件優先級與批處理
2. 引入非同步事件隊列（但保持結果確定性）
3. 進行性能基準測試

```typescript
// 優化例
class TickExecutor {
  execute(tick: Tick) {
    // 按優先級分批處理
    const events = this.collectAndSortEvents()

    // 低優先級事件可非同步（最後同步）
    const critical = events.filter((e) => e.priority > 5)
    const normal = events.filter((e) => e.priority <= 5)

    this.processCritical(critical) // 同步
    this.processNormalAsync(normal) // 非同步，但 Tick 結束前同步
      .then(() => {
        // 聚合結果
        this.snapshotStats()
      })
  }
}
```

---

## 3. 數值溢出的處理 ⚠️

### 選擇

endless.blueprint.md 使用**套件處理大數值顯示**

### 問題

**未權衡數值溢出對計算精度的影響**

特別在指數級難度曲線下

```
風險案例：
- 玩家傷害：1 KKK（1 × 10^33）
- 敵人 HP：1 TTT（1 × 10^39）
- 計算一次傷害：10^33 - 10^39 = ?

精度問題：
- 浮點精度丟失
- 結果難以預測
- 前後端不同步
```

### 建議

1. 定義「最大允許數值」
2. 使用 BigInt 或高精度庫
3. 測試邊界情況

```typescript
// 使用 BigInt
const damage = BigInt('12345678901234567890')
const hp = BigInt('98765432109876543210')
const remaining = hp - damage // 精確

// 或定義上限
const MAX_VALUE = 1e20 // 100 QQQQQ 以下
if (value > MAX_VALUE) {
  value = MAX_VALUE // 飽和
}
```

---

## 4. 物品欄限制的系統負載 ⚠️

### 選擇

inventory.blueprint.md 設定**裝備與遺物上限 999**

### 問題

**未考慮存儲與查詢效率**

```
性能風險：
- 玩家物品 999 件
- 查詢「某屬性的物品」？O(n) 搜索
- 排序 999 件？
- 存檔大小？

數據庫風險：
- JSON 欄位 999 條記錄
- 每次讀寫都需要反序列化
- 索引無法使用
```

### 建議

1. 實現分頁查詢
2. 使用資料庫索引
3. 考慮軟上限

```typescript
// 優化例
class InventoryService {
  async getWeapon(filter: WeaponFilter, page: number = 0) {
    // 資料庫查詢，帶索引，有分頁
    return db.query({
      userId: user.id,
      type: 'weapon',
      rarity: filter.rarity,
      // ...其他過濾
      limit: 20,
      offset: page * 20,
    })
  }
}

// 軟上限
const INVENTORY_SOFT_LIMIT = 200 // 玩家感知上限
const INVENTORY_HARD_LIMIT = 999 // 技術上限

// 達到軟上限時提示玩家
if (inventory.length > INVENTORY_SOFT_LIMIT) {
  showNotification('物品欄即將滿載，請整理')
}
```

---

## 5. 交易原子性的責任（過時）⚠️

### 選擇

shop.blueprint.md 強調**交易原子性由外部系統處理**

### 問題

**忽略內部邏輯與外部依賴的整合風險**

```
風險流程：
1. 本系統檢查：玩家有 100 金幣
2. 呼叫外部支付系統
3. 外部成功
4. 本系統更新：玩家金幣 = 0
5. ... 多設備同步時，另一設備也做了同樣操作

結果：玩家金幣被扣兩次
```

### 建議

1. 內部必須有原子性檢查
2. 實現樂觀鎖或分散式鎖
3. 定義明確的責任邊界

```typescript
// 改進的實現
async function purchaseItem(userId: string, itemId: string) {
  // 步驟 1：樂觀鎖
  const user = await db.getUser(userId)
  const version = user.version

  // 步驟 2：檢查金幣
  if (user.gold < item.price) {
    throw new Error('金幣不足')
  }

  // 步驟 3：呼叫外部系統
  const paymentResult = await externalPaymentSystem.charge(userId, item.price)

  if (!paymentResult.success) {
    throw new Error('支付失敗')
  }

  // 步驟 4：更新本地
  const success = await db.updateUser(
    {
      userId,
      version, // 版本檢查
    },
    {
      gold: user.gold - item.price,
      items: [...user.items, itemId],
      version: version + 1,
    }
  )

  if (!success) {
    // 版本衝突，回滾外部系統
    await externalPaymentSystem.refund(paymentResult.transactionId)
    throw new Error('版本衝突，請重試')
  }

  return { success: true }
}
```

---

## 重點梳理

| 選擇          | 獲得     | 犧牲     | 風險等級 | 建議            |
| ------------- | -------- | -------- | -------- | --------------- |
| 靜態詞綴      | 簡單性   | 隨機性   | 🟡       | 考慮混合方案    |
| Tick 事件隊列 | 確定性   | 性能     | 🟡       | 性能測試 + 優化 |
| 大數值套件    | 顯示簡潔 | 精度     | 🟡       | 邊界測試        |
| 999 物品限    | 容量     | 查詢效能 | 🟡       | 分頁 + 索引     |
| 外部交易責任  | 簡化     | 一致性   | 🔴       | 改進原子性檢查  |

---

## 標記

- 總體：大多數權衡合理，但需要細化實現
- 優先級：性能測試 > 精度測試 > 微調
