# 業界最佳實踐參考

## 概述

以下是在遊戲後端、分散式系統、Roguelite/卡牌/自動戰鬥類遊戲等領域被廣泛應用的理論與模式

這些方案能有效解決目前藍圖遇到的架構與可維護性問題

---

## 1. 事件系統（Event System）/ 事件驅動架構（EDA）

### 參考實例

- Unity Event System
- Node.js EventEmitter
- Domain Events（DDD）
- Observer Pattern
- Command Pattern

### 核心要素

- **事件類型嚴格定義**：enum 或 constant 管理所有事件類型
- **事件資料結構標準化**：統一的 Event 介面，包含 source, target, data
- **註冊/反註冊/優先級**：支援多個監聽者，按優先級執行
- **取消/冒泡機制**：事件可被攔截或阻止傳播
- **事件快照與重播**：記錄事件序列，支援重放

### TS 實作參考

- **mitt**：超輕量事件系統（<1KB）
- **RxJS**：響應式事件流
- **C# Event Aggregator**：DDD 中的事件總線概念

### 應用到本專案

適用於：

- Affix 觸發系統
- 戰鬥事件隊列
- 狀態變化通知
- 前端戰鬥重播

---

## 2. 屬性聚合與快照（Snapshot）

### 參考實例

- POE Stat Aggregation Pipeline（Path of Exile 屬性聚合）
- RPG Maker Stat Calculation
- Functional Reactive Programming（FRP）

### 核心要素

- **每個 Tick/Frame 聚合一次**：避免中途變動
- **聚合結果快照**：所有運算基於快照，不會互相影響
- **Immutable 數據結構**：防止意外修改
- **事件驅動更新**：狀態變化觸發重新聚合

### TS 實作參考

- **Immutable.js**：持久化不可變數據結構
- **Redux**：State Snapshot 範式
- **Event Sourcing**：所有狀態變化記錄為事件

### 應用到本專案

適用於：

- [03\_狀態與屬性聚合.md](03_狀態與屬性聚合.md) 中提到的 Snapshot Stats 方案
- 戰鬥屬性快照
- 前後端數值同步

---

## 3. 資料驅動設計（Data-Driven Design）

### 參考實例

- Unity ScriptableObject
- POE Data Tables（所有遊戲規則都是 JSON）
- 配置驅動的代碼架構

### 核心要素

- **所有規則資料化**：池、生成、條件、行為都是配置
- **邏輯與資料分離**：代碼只負責執行，不硬編碼規則
- **熱更新能力**：無需重啟服務就能調整
- **版本控制**：配置可版本化、可回滾

### TS 實作參考

- **JSON Schema**：定義配置結構，驗證
- **YAML/TOML**：人類可讀的配置格式
- **ConfigService**：集中配置管理

### 應用到本專案

適用於：

- [05\_生成與池表系統.md](05_生成與池表系統.md) 中的池表配置
- Affix 權重定義
- 難度係數配置
- 運營活動規則

---

## 4. 組件化設計（Component-Based Architecture）

### 參考實例

- Unity ECS（Entity-Component-System）
- Entity-Component-System 模式
- Component Pattern（設計模式）

### 核心要素

- **Unit/Entity 由可插拔組件構成**
- **組件職責單一**
- **組件間通過事件或介面通信**
- **易於擴展與測試**

### 架構示例

```
Unit
  ├─ StatsComponent（屬性計算）
  ├─ CombatComponent（戰鬥邏輯）
  ├─ AffixComponent（詞綴管理）
  ├─ StatusComponent（狀態管理）
  └─ EventComponent（事件發射）
```

### 應用到本專案

適用於：

- 敵人與玩家數據結構
- 技能系統
- 裝備系統

---

## 5. 策略模式（Strategy Pattern）與插件架構（Plugin Architecture）

### 參考實例

- POE Modifier Calculation（可插拔的 Modifier 計算）
- Blizzard Hotfix System（遊戲平衡調整系統）
- Spring Framework 的插件機制

### 核心要素

- **生成規則可注入**：運行時替換生成策略
- **池調整可插拔**：無需改代碼就能調整
- **活動規則隔離**：特殊規則不污染主流程
- **A/B Test 支援**：不同玩家不同規則

### TS 實作參考

- **Strategy Pattern**：定義介面，多個實現
- **Factory Pattern**：動態創建策略
- **Chain of Responsibility**：規則鏈

### 應用到本專案

適用於：

- [05\_生成與池表系統.md](05_生成與池表系統.md) 中的動態權重調整
- 活動專屬規則
- 難度係數應用

---

## 6. 防腐層（Anti-Corruption Layer, ACL）/ 限界上下文（Bounded Context）

### 參考實例

- Domain-Driven Design（DDD）
- 微服務架構的服務隔離
- 現代後端架構的跨域協作

### 核心要素

- **跨模組/服務協作必經 ACL**
- **ACL 翻譯不同模組的語言**
- **ACL 防止外部變動污染核心模型**
- **隱藏複雜性和實現細節**

### DDD 概念

```
核心模型（Domain）
  ↓
應用層（Application）
  ↓
防腐層（ACL - Adapter）
  ↓
外部系統
```

### 應用到本專案

適用於：

- [06\_架構設計缺陷.md](06_架構設計缺陷.md) 中的 ACL 設計
- 商店與金幣系統的隔離
- 外部支付系統的集成

---

## 7. 資料一致性與分散式鎖（Optimistic Locking, Distributed Lock）

### 參考實例

- DynamoDB Conditional Write
- MongoDB Version Field
- Redis Redlock
- PostgreSQL Advisory Locks

### 核心要素

- **樂觀鎖（版本號）**：適合低衝突場景
- **分散式鎖（Redis）**：適合高衝突場景
- **Conditional Write**：帶條件的原子操作
- **衝突回滾**：失敗時清理狀態

### 樂觀鎖範例

```typescript
// 版本檢查
const success = await db.update(
  {
    id: userId,
    version: currentVersion, // 檢查版本匹配
  },
  {
    data: newData,
    version: currentVersion + 1,
  }
)

if (!success) {
  // 版本不匹配，重試
}
```

### 分散式鎖範例

```typescript
// Redis Redlock
const lock = await redis.acquire(`user:${userId}:lock`)
try {
  // 執行原子操作
  await modifyUserData()
} finally {
  await redis.release(lock)
}
```

### 應用到本專案

適用於：

- [06\_架構設計缺陷.md](06_架構設計缺陷.md) 中的多設備同步
- 交易原子性
- 代幣消費

---

## 8. 事件溯源（Event Sourcing）與重播（Replay）

### 參考實例

- CQRS/Event Sourcing 架構
- POE Combat Log Replay（戰鬥日誌重放）
- Slay the Spire Replay（牌組重放）
- Event Store 資料庫

### 核心要素

- **所有狀態變化記錄為事件序列**
- **可重播還原歷史狀態**
- **方便 debug 與審計**
- **支援時間旅行**

### Event Sourcing 流程

```
User Actions
    ↓
Events（不可變事件序列）
    ↓
Event Store（持久化）
    ↓
Projections（計算得到的狀態）
    ↓
Query Model（給前端用的狀態）
```

### 應用到本專案

適用於：

- [09\_不完備與缺口.md](09_不完備與缺口.md) 中的戰鬥日誌
- 戰鬥重播
- 玩家行為追蹤

---

## 9. 測試性與可觀測性（Testability & Observability）

### 參考實例

- Hexagonal Architecture（六邊形架構）
- Test-Driven Development（TDD）
- Structured Logging（結構化日誌）
- OpenTelemetry

### 核心要素

- **所有流程可插拔測試點**：介面清晰，易於 mock
- **日誌結構化**：JSON 日誌，便於分析
- **追蹤 ID**：每個操作帶全局追蹤 ID
- **指標監控**：性能、錯誤率等

### TS 實作參考

- **Jest**：單元測試
- **Supertest**：集成測試
- **Winston/Pino**：結構化日誌
- **OpenTelemetry**：分佈式追蹤

### 應用到本專案

適用於：

- 詞綴系統的單元測試
- 戰鬥邏輯的集成測試
- 屬性聚合的性能測試
- 運營監控

---

## 10. 資料版本管理與升級（Schema Versioning & Migration）

### 參考實例

- Protocol Buffers（向後兼容）
- Avro（模式演進）
- MongoDB Schema Validation
- POE Save Format Evolution（從 2006 到 2024 的存檔兼容）

### 核心要素

- **Version 欄位**：每個資料結構都有版本
- **升級策略明確**：定義如何從舊版升級到新版
- **兼容舊資料**：新代碼能讀老存檔
- **遷移腳本**：自動化升級流程

### 升級策略

```typescript
interface VersionedData {
  version: '1.0' | '1.1' | '2.0' // 明確版本
  data: any
}

function migrateData(old: VersionedData): VersionedData {
  switch (old.version) {
    case '1.0':
      return migrateFrom1_0To1_1(old)
    case '1.1':
      return migrateFrom1_1To2_0(old)
    default:
      return old
  }
}
```

### 應用到本專案

適用於：

- [06\_架構設計缺陷.md](06_架構設計缺陷.md) 中的 Context 序列化
- 存檔升級
- 跨版本相容性

---

## 11. 遊戲平衡與數值驗證（Game Balance & Simulation）

### 參考實例

- POE Simulation Tools（數值驗證）
- Slay the Spire Simulator（牌組模擬）
- Auto Chess Simulator（博弈模擬）

### 核心要素

- **自動化數值驗證**：跑數千場戰鬥驗證平衡
- **極端案例模擬**：最強 vs 最弱的組合
- **成長曲線可視化**：查看玩家進度曲線
- **性能基準測試**：監控性能回歸

### 實作方向

```typescript
// 數值驗證
async function validateBalance() {
  const results = []

  for (let run = 0; run < 1000; run++) {
    const battle = await simulateBattle({
      seed: run,
      difficulty: 5,
      numberOfEnemies: 10,
    })

    results.push({
      run,
      playerWinRate: battle.playerWins / battle.totalBattles,
      averageTurns: battle.averageTurns,
    })
  }

  return analyzeResults(results)
}

// 成長曲線分析
function analyzeGrowthCurve(runs: Run[]) {
  return {
    chapter1: runs.filter((r) => r.chapter === 1).map((r) => r.playerStats),
    chapter5: runs.filter((r) => r.chapter === 5).map((r) => r.playerStats),
    // 檢測數值爆炸
  }
}
```

### 應用到本專案

適用於：

- [08\_權衡利弊分析.md](08_權衡利弊分析.md) 中的性能與平衡測試
- 無盡模式的難度驗證
- 詞綴組合的平衡驗證

---

## 12. 資料本地化與國際化（i18n/l10n）

### 參考實例

- Unity Localization
- POE Data Tables（支援多語言）
- React-i18next
- ICU 消息格式

### 核心要素

- **資料結構與本地化資源分離**
- **支援多語系熱更新**
- **複數、性別等語言規則**
- **地區化（如日期、貨幣格式）**

### TS 實作參考

- **i18next**：標準化國際化框架
- **翻譯文件**：JSON 或 YAML 格式

### 應用到本專案

適用於：

- 遊戲文本（詞綴描述、技能名稱等）
- 日期與時間顯示
- 貨幣與數值格式

---

## 優先級建議

### 第一階段（急迫）

1. **事件系統**：影響戰鬥核心
2. **屬性快照**：影響數值一致性
3. **資料驅動**：影響擴展性

### 第二階段（重要）

4. **組件化設計**：改進結構
5. **防腐層**：改進解耦
6. **分散式鎖**：改進一致性

### 第三階段（優化）

7. 測試與可觀測性
8. 版本管理
9. 平衡驗證
10. 國際化

---

## 標記

- 推薦按優先級順序應用
- 每個實踐可逐步引入，無需一次性全改
- 結合現有藍圖進行適應性調整
